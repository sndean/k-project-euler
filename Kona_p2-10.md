
# Problem 2

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

> > 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


## Kona

First we have to find a way to obtain the Fibonacci sequence. Let's see how to obtain the first 10 terms

```
  9 {x,+/-2#x}/1
1 2 3 5 8 13 21 34 55 89
```

To break that down, we need to be able to sum two numbers and we know the sequence we want starts with `1, 2`. First, obtain the last two numbers

```
  {-2#x} 1 2 3
2 3
  {-2#x} 4 5 6
5 6
```

Then `+/`

```
  {+/-2#x} 1 2
3
  {+/-2#x} 2 3
5
  {+/-2#x} 3 5
8
  {+/-2#x} 5 8
13
```

So that seems to work correctly. Next, we need to join the result to the input. We can do that using join (`,`)

```
  {x,+/-2#x} 5 8
5 8 13
```

Next we want to apply this `n` times. For this, we can use the over monad `/` where you can apply `n` times like so: `n f/x`. (Example: `4 (2+)/1` which yields `9`, meaning "to 1, add 2 four times.")

```{}
  9 {x,+/-2#x}/1
1 2 3 5 8 13 21 34 55 89
  10 {x,+/-2#x}/1
1 2 3 5 8 13 21 34 55 89 144
```

Now that we have that, the rest is relatively simple.

We need the term that's the term immediately prior to that which is over 4 million. First, I should point out that in Kona you can abbrevate large numbers with scientific notation, so `4000000` becomes `4e6`.

```{}
  4e6 = 4000000
1
```

Next we want all the terms under the one that's `>4e6`.
You can make provide a binary "`1` = keep going, `0` = stop" with `>`. 

```  
  {55>+/-2#x} 1 2 3 5 8 13
1
  {55>+/-2#x} 1 2 3 5 8 13 21
1
  {55>+/-2#x} 1 2 3 5 8 13 21 34
0
```

```{}
  (4e6>+/-2#){x,+/-2#x}/1
1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 
6765 10946 17711 28657 46368 75025 121393 196418 317811 
514229 832040 1346269 2178309 3524578
```

Now let's find the even-valued terms. Use modulus `!` and not `~`, where if 1 is left after mod 2, it's odd, so *don't* take that number.

```
  {~x!2} 10
1
  {~x!2} 11
0
```

Then obtain the index of the list with where `&`.

```{}
  {~x!2} (4e6>+/-2#){x,+/-2#x}/1
0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1
  {&~x!2} (4e6>+/-2#){x,+/-2#x}/1
1 4 7 10 13 16 19 22 25 28 31
```

And find the corresponding spot in `x` with at `@`.

```

  {x@&~x!2} (4e6>+/-2#){x,+/-2#x}/1
2 8 34 144 610 2584 10946 46368 196418 832040 3524578
```

The main interesting thing there is the `@` verb which is the dyadic `at`, which pulls the value from x at indices y. Some examples.

```{}
  {x@1} 4 2 1 9
2
  {&x=2} 4 2 1 9
,1
  {x@&x=2} 4 2 1 9
,2
```


Finally, all we have to do is sum (`+/`).

```{}
  +/{x@&~x!2}(4e6>+/-2#){x,+/-2#x}/1
4613732
```

















# Problem 3

> The prime factors of 13195 are 5, 7, 13 and 29.

> What is the largest prime factor of the number 600851475143 ?


## Kona

Kona's Project Euler [page](https://github.com/kevinlawler/kona/wiki/Project-Euler-Code-Golf) has a solution that is sort of a hack that doesn't generalize well (e.g., doesn't work for 15), but it works for 600851475143:


```{}
  |/d@&&/'2_'f'd:&~(f:{x!'!1+_sqrt x})600851475143
6857

  |/d@&&/'2_'f'd:&~(f:{x!'!1+_sqrt x})15
3
```

Let's see if we can come up with something that is generalizable. First, we can use code from [hakank's website on k](http://www.hakank.org/k/) (or Kona's [Idioms page](https://github.com/kevinlawler/kona/wiki/Idioms)) for listing all of the primes up to `n` (primes_to_n_sieve2 -> p). 

```{}
  p:{:[x<4;,2;r,1_&~|/x#'~!:'r:_f[_-_-_sqrt x]]}
  p 100
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```

(`p:2_&{&/x!'2_!x}'!:` and other ways also work, but some of them are slow.)


Using this, we can essentially use this a lookup table for large prime factors of 600851475143. As long as we set `x` to be very high, e.g., `10000` or `100000`, then that should be cover the greatest prime factors of very large numbers. This is a bit of a cheat, but it's similar to the cheat of take taking the `sqrt` of an input and only calculating the prime factors below that, which is done for a lot of Problem 3 solutions.

Using this large list, we can run mod eachright (`!/:`) of our test number against all of the primes up to 10000:

```{}
  15 !/: p 10000
1 0 0 1 4 2 15 15 15 15 15 15 15 15 15 15 15 ...
```

Next, put that in a function and add the not where at code that we used earlier in front:

```{}
  {x@&~15!/:x}p 10000
3 5
```

Finally, just take the highest value (`|/`):

```{}
  {|/x@&~15!/:x}p 10000
5
```

And this solution is generalizable up to large values:

```{}
  p:{:[x<4;,2;r,1_&~|/x#'~!:'r:_f[_-_-_sqrt x]]}
  {|/x@&~600851475143!/:x}p 10000
6857
```

or on one line:

```{}
  {|/x@&~600851475143!/:x}{:[x<4;,2;r,1_&~|/x#'~!:'r:_f[_-_-_sqrt x]]} 10000
6857
```










































# Problem 4

> A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

> Find the largest palindrome made from the product of two 3-digit numbers.


## Kona

First, how do we test if we have palindromic number in Kona? 

Reversing the value of a number doesn't sense, but since strings in Kona are lists of characters, we can simply convert numbers to strings using `$`:

```{}
  $99
"99"
```

Now that we have a testable object, we can test if it's a palindrome via reverse `|` and match `~`. Something like this:

```{}
  ($99) ~| ($99)
1
  ($100) ~| ($100)
0
```

Converting this reverse-match an anonymous function makes it work quicker:

```{}
    {x~|x} ($99)
1
    {x~|x} ($100)
0
    {x~|x} ($101)
1
    {x~|x} ($102)
0
    {x~|x} ($103)
0
```

Now let's test all of the numbers from 0-99 to find which are palindromic, and where they're located:

```{}
    {x~|x}' ($!100)
1 1 1 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 
0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 
0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 
0 0 0 0 0 0 1

    &{x~|x}' ($!100)
0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99
```

And we can find the largest palindrome by using `|/`:

```{}
  |/&{x~|x}' ($!100)
99
```

Now that we have that down, what about the "from the product of two 3-digit numbers" part of the question? 

That's relatively simple in Kona. Let's do that with numbers from 0-9 first. So from `0*0` to `9*9`, where join `,` creates a vector of all the results:

```{}
  ,/a*/:a:!10
0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 0 2 4 6 8 10 12 14 
16 18 0 3 6 9 12 15 18 21 24 27 0 4 8 12 16 20 24 28 32 36 
0 5 10 15 20 25 30 35 40 45 0 6 12 18 24 30 36 42 48 54 0 
7 14 21 28 35 42 49 56 63 0 8 16 24 32 40 48 56 64 72 0 9 
18 27 36 45 54 63 72 81
```

Now we can put these together:

```{}
  |/&{x~|x}' ($b:,/a*/:a:!100)
9991
```

But... that result doesn't make sense. We forgot the dyadic `@` (pulls the value from x at indices y):

```{}
  |/b@&{x~|x}' ($b:,/a*/:a:!100)
9009
```

Finally, let's remove the unnecessary parentheses and scale it up to 3-digit numbers:

```{}
  |/b@&{x~|x}'$b:,/a*/:a:!1000
906609
```

It's a little slow, but it works.




































# Problem 5

> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?


## Kona

Here the goal is to find the smallest (+) number where `!` = 0 for all numbers between 1 and 20. For easier calculations, we'll work with numbers 1 to 7: 

```{}
  419 !/: (1+!7)
0 1 2 3 4 5 6
  420 !/: (1+!7)
0 0 0 0 0 0 0
  421 !/: (1+!7)
0 1 1 1 1 1 1
```

420 is the smallest number for numbers 1 to 7, with the result being all zeros. 

Now, we don't have to check every number going from 0 to 420, we can skip by 7:

```{}
  60{x+7}\0
0 7 14 21 28 35 42 49 56 63 70 77 84 91 98 105 112 119 
126 133 140 147 154 161 168 175 182 189 196 203 210 217 
224 231 238 245 252 259 266 273 280 287 294 301 308 315 
322 329 336 343 350 357 364 371 378 385 392 399 406 413 420
```

And you can then do something like this:

```{}  
  a:(1000{x+7}\7)
  a@&~+/{x!/:(1+!7)}a
420 840 1260 1680 2100 2520 2940 3360 3780 4200 4620 5040 5460 5880 6300 6720
```

This even works well enough to find the solution for 1-10:

```{}
  a:(1000{x+10}\10)
  &/a@&~+/{x!/:(1+!10)}a
2520
```

But as soon as you try something like 1-20, the little program never terminates (or at least I didn't have enough patiences to see it stop). So, we need a better way.

The even better solution uses the _least common multiple_, which is a method listed on [Kona's Github page](https://github.com/kevinlawler/kona/wiki):

```{}
  {x*y%{:[_ y;_f[y]x!y;x]}[x]y}/1+!20
232792560
```

Which is great, but for input = 100, this is the result:

```{}
  {x*y%{:[_ y;_f[y]x!y;x]}[x]y}/1+!100
-5604188662061589568
```

Which isn't right... So, we found a better way, but maybe we need an _even better_ way.


### Exponent method

Taking 20 as our example, we know the LCM must be divisible by every prime `<= 20`. In this case those primes are 2, 3, 5, 7, 11, 13, 17, and 19.

Now, using the greatest exponent of each prime, multiply them together as: $2^4 \times 3^2 \times 5 \times 7 \times 11 \times 13 \times 17 \times 19 = 232792560$. Here, we can use the built-in `_log` function to determine the exponent of the prime, `p`, as `log(20)/log(p)` by passing through the primes.

```{}
  p:2_&{&/x!'2_!x}'!:
  p 10
2 3 5 7
  {(_log 10)%(_log x)} p 10
3.321928094887362626 2.095903274289384832 1.430676558073393334 1.183294662454938528
  {_(_log 10)%(_log x)} p 10
3 2 1 1
  {x^_(_log 10)%(_log x)} p 10
8 9 5 7.0
  */_{x^_(_log 10)%(_log x)} p 10
2520
```

```{}
  p:2_&{&/x!'2_!x}'!:
  */_{x^_(_log 20)%(_log x)} p 20
232792560
```

But this solution fails when you test other (lower) values:

```{}
    */_{x^_(_log 7)%(_log x)} p 7
60
```

This should be 420, not 60.

What I didn't initially realize, is that the prime sieve needs to be inclusive if the input is an odd number, but exclusive if it's an even number. The current prime sieve function I'm using is an exclusive only function, which is fine if it's an even input. So, if we're happy with a 20-only solution for Project Euler, that's fine... but it's annoying. So here's the prime sieve with if-else logic:

```{}
  p:{:[~x!2; :2_&{&/x!'2_!x}'!: x; 1; x,:2_&{&/x!'2_!x}'!: x;]}
  */_{x^_(_log 20)%(_log x)} p 20
232792560
```

Cleaning it up a bit further (removing unnecessary parentheses and removing the `p` from the outside):

```{}
  p:{:[~x!2;:2_&{&/x!'2_!x}'!:x;1;x,:2_&{&/x!'2_!x}'!:x;]}
  {*/_(p x)^_(_log x)%_log p x} 7
420
  {*/_(p x)^_(_log x)%_log p x} 10
2520
  {*/_(p x)^_(_log x)%_log p x} 20
232792560
```

If we simply remove the `_` from the function, we can see that it yields the correct solution (at least the first several digits) for 100:

```{}
    {*/(p x)^_(_log x)%_log p x} 100
6.972037522971248629e+40
```

And this method now works for odd numbers as well (yay!).

The if-else logic in Kona works like this:

`:[x1;t1;x2;t2;...;xn;tn;else]` evaluate `xi` until true (or, `1`) and return `ti`, otherwise return else. Example:

```{}
  :[1;10;0;20;1;30;40]
10
  :[0;10;0;20;0;30;40]
40
  :[0;10;1;20;0;30;40]
20
```

And here's a simplified and more relevant example:

```{}
  {:[~x!2; x*2; 1;!x;]} 1
,0
  {:[~x!2; x*2; 1;!x;]} 2
4
  {:[~x!2; x*2; 1;!x;]} 3
0 1 2
  {:[~x!2; x*2; 1;!x;]} 4
8
  {:[~x!2; x*2; 1;!x;]} 5
0 1 2 3 4
```

In this function `{:[~x!2; x*2; 1;!x;]}`, the condition is `~x!2`, so if the input is even the flow goes to the first option and `x*2`. If the input is odd, the flow goes to the else option: `!x`.
















































# Problem 6

> The sum of the squares of the first ten natural numbers is,

>> 1^2 + 2^2 + ... + 10^2 = 385

> The square of the sum of the first ten natural numbers is,

>> (1 + 2 + ... + 10)^2 = 55^2 = 3025

> Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.

> Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.


## Kona

```{}
  {_(_sqr+/x)-+/x^2}1+!100
25164150
```




































# Problem 7

>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

>What is the 10001st prime number?


## Kona

```{}
  p:2_&{&/x!'2_!x}'!:
  (p 200000)[10000]
104743
```

This is a function that generates all of the primes up to 200000, which includes the 10001st prime, and uses the index of 10000 to pull out the 10001st prime. It provides the correct answer, but it's _incredibly_ slow. (I literally fell asleep yesterday waiting for it to finish.)

The solutions listed on Kona's Github page also appear to be unsatisfactorily slow (though slightly faster than the above):

```{}
 p:2;i:3;while[10001>#p;if[{&/x!'p} i;p,:i];i+:1];*|p
```

So, here, I'll try to come up with some better solutions to reach the answer in under a minute (and most likely using a lot more k code).

### Prime Number Theorem

The first thing to do is to have good way to know how far you need to go (how many primes will show up before $n$). The prime number theorem (PNT) is a useful tool for that. For our purposes, it's enough to say that the number of primes before $n$ is approximately $x/log(x)$. Some examples:

```{}
  \p 0
  p:2_&:({&/x!'2_!x})'!:
  xlogx:{x % _log x}
  
  # p 10
4
  xlogx 10
4.342944819032517501

  # p 100
25
  xlogx 100
21.71472409516259106

  # p 1000
168
  xlogx 1000
144.7648273010839546

  # p 10000
1229
  xlogx 10000
1085.736204758129361

```

So what about the 10001st prime? Let's see how close we can cut it:

```{}
  xlogx 116700
10002.26116389158415
```

This already appears to be an improvement. Instead of my initial try of looking in the first 200000 numbers, here we're looking at the first ~115000. 

### Sieve of Atkin

The [Sieve of Atkin](https://en.wikipedia.org/wiki/Sieve_of_Atkin) is supposeedly the fastest algorithm for finding all prime numbers up to a specified integer. Let's see if we can implement it.














































# Problem 8

> The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

> 73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

> Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

## Kona


First, you have to be able to read in text files:

```{}
  {x}0$',/0:`pe8.txt
7 3 1 6 7 1 7 6 5 3 1 3 3 0
```

And count the number of numbers:

```{}
  {#x}0$',/0:`pe8.txt
1000
```

One reasonable way to solve this problem is to create a `4 x n` matrix, using a sliding window:

```{}
  (!10) @(!4)+/:!-3+# (!10)
(0 1 2 3
 1 2 3 4
 2 3 4 5
 3 4 5 6
 4 5 6 7
 5 6 7 8
 6 7 8 9)
```

Now, using the 1000 digits:

```{}
  {x@(!4)+/:!-3+#x}0$',/0:`pe8.txt
(7 3 1 6
 3 1 6 7
 1 6 7 1
 6 7 1 7 
 ...
```

```{}
  */'{x@(!4)+/:!-3+#x}0$',/0:`pe8.txt
126 126 42 294 294 210 630 90 45 27 0 0 0 0
```

And finally, the maximum:

```{}
  |/ */'{x@(!4)+/:!-3+#x}0$',/0:`pe8.txt
5832
```

Now with a 13-wide window:

```{}
  |/(*/'{x@(!13)+/:!-12+#x}0$',/0:`pe8.txt)
23514624000
```

Now, maybe there's a good idea, where rows with zeros are removed first.

An attempt to get rid of all of the zeros first:

```{}
  {x@&~0_in'x@(!13)+/:!-12+#x}0$',/0:`pe8.txt
7 6 2 4 9 1 9 2 2 5 1 1 9 6 7 4 4 2 6 5 7 4 
```


Simplified example for a way to remove rows from a matrix based on a condition. In this case, remove any rows containing a `0`.

```{}
  {x[&3=x?\:0]}(1 2 3;4 5 6;7 8 9)
(1 2 3
 4 5 6
 7 8 9)
  
  {x[&3=x?\:0]}(1 2 3;4 5 0;7 8 9)
(1 2 3
 7 8 9)
 
  {x[&3=x?\:0]}(1 0 3;4 5 0;7 8 9)
,7 8 9
```


The dimensions of the rows without zeros:

```{}
  ^ xx[&13=(xx ?\: 0)]
263 13
```

That's a signficant decrease in rows to check.

There's probably a better way to implement it, but if you time the second version (where you remove zeros first) and compare it to the first version, the first version is faster...:

```{}
  |/{*/'x@(!13)+/:!-12+#x}0$',/0:`pe8.txt
23514624000
  |/{*/'x[&13=x?\:0]}{x@(!13)+/:!-12+#x}0$',/0:`pe8.txt
23514624000
  \t |/{*/'x@(!13)+/:!-12+#x}0$',/0:`pe8.txt
1
  \t |/{*/'x[&13=x?\:0]}{x@(!13)+/:!-12+#x}0$',/0:`pe8.txt
2
```













































# Problem 9

> A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

> a^2 + b^2 = c^2
> For example, 3^2 + 4^2 = 9 + 16 = 25 = 52.

> There exists exactly one Pythagorean triplet for which a + b + c = 1000.
> Find the product abc.


## Kona

```{}
*/_*c@&1000=+/'c:b,'(_sqrt+/)'b*b:,/a,/:\:a:!500
```









































# Problem 10

> The prime factors of 13195 are 5, 7, 13 and 29.

> What is the largest prime factor of the number 600851475143 ?


## Kona

```{}
p:{2_&{:[x@y;x&@[1,-1_ z#(1_ y#1),0;y;:;1];x]}/[x#1;2_! __ceil _sqrt x;x]};+/p@_2e6	
```
