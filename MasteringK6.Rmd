---
title: "Mastering K6"
author: "S.N. Dean"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '4'
  pdf_document:
    toc: yes
    toc_depth: 4
  word_document:
    toc: yes
    toc_depth: '4'
fontsize: 11pt
---


 <!-- Aim: >300 pages -->
 <!-- where ok and k6 behavior differs, add the comment: -->
 <!---- note: behavior differs from oK -->
 <!---- and/or write and bookmark in the book -->
 <!-- gray bar (e.g., 1.2 Three Basic Applications) is equivalent to 
 <!---- "## 7.2 Three Basic Applications" -->


# Chapter 1


## 1.1 Introduction


### Short history and design of APL

```{r, echo=FALSE}
knitr::include_graphics("/Users/snd/org/Writing/images/Genealogical_tree_of_programming_languages.svg.png")
```

There are many different lineages and paradigms of programming language. The language that this book is dedicated to is a decendent of an ancient programming language called APL ^[http://www.softwarepreservation.org/projects/apl/Books/APROGRAMMING%20LANGUAGE/view]. In the world of computer programming languages, 1964 is ancient: few other languages from that era are still in use today ^[https://en.wikipedia.org/wiki/History_of_programming_languages#First_programming_languages]. Created by [Ken Iverson](https://en.wikipedia.org/wiki/Kenneth_E._Iverson), APL featured, most notably, a large set of symbols or glyphs, and, perhaps more importantly, the multidimensional array as its central datatype - in APL, 

```{}
      1 2 3 + 4 5 6
5 7 9
```





### What is K?

K is a proprietary array processing language developed by Arthur Whitney and commercialized by Kx Systems. Since then, an open-source implementation known as Kona has also been developed.[1] The language serves as the foundation for kdb+, an in-memory, column-based database, and other related financial products.[2] The language, originally developed in 1993, is a variant of APL and contains elements of Scheme. Advocates of the language emphasize its speed, facility in handling arrays, and expressive syntax.[3]

K is a synthesis of APL and LISP. Although many of the capabilities come from APL, the fundamental data construct is quite different. In APL the construct is a multi-dimensional matrix-like array, where the dimension of the array can range from 0 to some maximum (often 9). In K, like LISP, the fundamental data construct is a list. The K language is ASCII-based.

For many people, K was the preferred APL dialect. When it was available, it tended to be popular with investment bankers, the performance obsessed, and analysts dealing with lots of data. It is a demanding language.

K was originally designed by [Arthur Whitney](https://en.wikipedia.org/wiki/Arthur_Whitney_(computer_scientist)) and Kx Systems. Praise for K should be taken to refer to Kx's K. Kx sells a popular database called KDB+. People can and do create networked trading platforms in hours. If your business needs production support, you can evaluate KDB+ prior to purchasing from Kx, or possibly speak with Kx consulting partner First Derivatives. The 32-bit version of KDB+ is available for free.

Kx's KDB+ uses the Q language, and is built on top of K4. Kx used to sell a database called KDB, which used the KSQL language, and was built on top of K3. Earlier, Kx sold K2 as its primary product. Before K2, UBS had a 5-year exclusive license to K1. To the confusion of all, these terms are used interchangeably. Kx's K3, K2 and K1 are basically no longer available. While you get K4 with KDB+, K4 is proprietary to Kx and no documentation is available. Kona is a reimplementation that targets K3 but includes features inferred from K4 or implemented elsewhere. Kona is unaffiliated with Kx.



#### History of K

Before developing K, Arthur Whitney had worked extensively with APL, first at I. P. Sharp Associates alongside Ken Iverson and Roger Hui, and later at Morgan Stanley developing financial applications. At Morgan Stanley, Whitney helped to develop A+, a variant of APL, to facilitate the migration of APL applications from IBM mainframes to a network of Sun workstations. A+ had a smaller set of primitive functions and was designed for speed and to handle large sets of time series data.[4]

In 1993, Whitney left Morgan Stanley and developed the first version of the K language. At the same time he formed Kx Systems to commercialize the product and signed an exclusive contract with Union Bank of Switzerland (UBS). For the next four years he developed various financial and trading applications using K for UBS.

The contract ended in 1997 when UBS merged with Swiss Bank. In 1998, Kx Systems released kdb+, a database built on K. kdb was an in-memory, column-oriented database and included ksql, a query language with an SQL-like syntax. Since then, a number of financial products have been developed with K and kdb+. kdb+/tick and kdb+/taq were developed in 2001. kdb+, a 64-bit version of kdb+ was released in 2003 and kdb+/tick and kdb+/taq were released in 2004. kdb+ included Q, a language that merged the functionality of the underlying K language and ksql.[5]




#### What is K6?


oK is a toy interpreter for a dialect of the K programming language which aims to be an implementation of K5, the still-evolving bleeding edge version of the language. Expect oK to be buggy, incomplete and occasionally flat-out wrong, but slowly improving over time. Read the oK Manual for an overview of oK's operators and syntax.

If you are interested in learning more about K, consider downloading the free version of kdb from Kx Systems, the fine makers of K. Alternatively, Kona is an open-source reimplementation of K3/K4.

oK does not intend to be particularly fast or suitable for any practical purpose beyond learning, instead emphasizing simplicity of implementation. JavaScript was chosen as an implementation language because it is familar to many programmers and has first-class functions.




### Inspiration

This book was inspired by *Mastering Dyalog APL* by Bernard Legrand (free [here](https://www.dyalog.com/uploads/documents/MasteringDyalogAPL.pdf)). If you're trying to learn APL, I suggest going all of the way through the massive book. I was a big help in (though not necessarily a prerequisite to) learning K. Also inspiring are open source K projects [oK](https://github.com/JohnEarnest/ok) (by [John Earnest](https://github.com/JohnEarnest)) and [Kona](https://github.com/kevinlawler/kona) (by [Kevin Lawler](https://github.com/kevinlawler)/[Tom Szczesny](https://github.com/tavmem)). These open source projects are all based on [Kx](https://kx.com/)'s various iterations of K.


### Organization of this book

This book is organized such that the first chapter is sufficient for a basic understanding of K6. It's more or less a standalone. After working through the first tutorial chapter, you can theoretically go through the remaining chapters in whatever order you wish to gain a more in-depth understanding of K. However, I would suggest going through all of the chapters one-by-one. For those who have experience with APL or APL-family languages, some parts may be painfully slow, as this book doesn't assume prior programming experience, and it certainly doesn't assume prior experience with APL. Plots used throughout this book are not implimented in K, but in R using [ggplot2](http://ggplot2.tidyverse.org/). These are unnecessary, but very useful, for understanding K, its uses, and how its work is performed on data. In cases where the printing of output and others is ugly (sometimes it is), `\n` were used instead of `;`, but the majority of the output is identical to that of the K6 REPL (_2016.08.09_).


### Installation

It's highly recommended that you use the version of K (oK = K5/K6) implemented by [John Earnest](https://github.com/JohnEarnest) [here](https://github.com/JohnEarnest/ok) while going through this book. Most of it is compatible with the bleeding-edge version of K6 that can be understood from the [reference card](http://kparc.com/k.txt). In fact, the different dialects of K differ enough, that you *must* use oK or K6 to go through the examples found within this book.

#### Linux & MacOS

To install oK on MacOS and various flavors of Linux:

```{}
git clone https://github.com/JohnEarnest/ok.git
cd ok
./repl.js
```

To obtain a nicely-functioning REPL, I have `alias ok='Users/snd/ok/repl.js'` in my ~/.bashrc.

















## 1.2 First steps with K

### Simple operations
In K, what you type starts with `" "`, a one-character indent from the left margin. The read-eval-print-loop (REPL) responds to input, which it displays at the left margin. For the purposes of this book, essentially all code will be presented as if you're looking at the REPL. It's likely a good idea for you to have your own REPL open along side to follow along. 

Let's start:

```{}
 151 + 122
273
 512 - 84
428
 601 * 12
7212
 341 % 7
48.71429
```


You can see that K behaves like any hand-held calculator with, however, a small difference; multiplication is represented by the multiplication symbol `*` and for division, `%`. Unlike APL's `×` and `÷`, K uses only ASCII characters. Also, you may notice later, that K generally uses a very concise and code-golf-like style where spaces are generally not used unless required (they almost never are) and very short names. There are several reasons for this, explained elsewhere ^[[Smaller code, Better code by Aaron Hsu](http://www.sacrideo.us/smaller-code-better-code/)]. For purposes of reading, I'll use slightly *expanded* or *larger* code (e.g., variable names with more than a single character and a space or two).

If you are familiar with other programming languages, you may occasionally and erroneously use `/` instead of `%` . Let's see what might happen then:

```{}
 341 / 8              / nothing happens because you have commented out the divisor
```


### Variables

Like any other programming language, you can create variables. Just choose a name (short and lower case is the norm in K) and use `:` to assign it a value. 

```{}
 percent:17.2      / percent : 17.2 works too. In this case, spaces do not matter
```

To ask for the contents of a variable, just type its name and press `Return`, like this:

```{}
 percent:17.2
17.2
```

K is *case sensitive*, so `percent` and only `percent` are assigned the value `17.2`. `PERCENT` and `percent` will return

```{}
 PERCENT
PERCENT
^
value error
  
 percent
17.2
```


### Array processing

If two vectors have the same shape, you can do operations on them. E.g., let's say that you have a list of approximate miles per gallion (mpg) fuel efficiency and value of 20 cars you see drive by, binned by mpg:

mpg | number | value
------ | ------ | ------
10 | 2 | 20
15 | 4 | 27
20 | 5 | 29
25 | 6 | 19
30 | 3 | 22

You can create the variables like this:

```{}
 mpg:10 15 20 25 30
 number:2 4 5 6 3
 value:20 27 29 19 22 
```

Now, since you have a price and quantity for each item, you can (using the obvious `*` verb) multiply them together and produce a result of the same length. That result can then be assigned to a new variable:

```{}
 a:mpg * number
 a
20 60 100 150 90
```

The array processing capability of K eliminates the need to use loops, common in many other programming languages. This characteristic greatly simplifies the code of scripts and programs written in APL-family languages.


As another example imagine that a metorologist makes a difficult forecast: the amount of rain/month (in mm) over the next 2.5 years, broken into rows of six months, which are assigned to `predict`, using a new model. At the end of the 2.5 years, they assign the real values to the variable `real`, in the same format:

predict | real
-------- | -------
150 200 100 80 80 70 | 141 188 111 87 82 97
300 100 50 200 330 500 | 321 306 352 403 497 72
250 120 100 80 80 110 | 118 283 397 424 411 120
360 400 500 520 350 420| 43 91 187 306 318 301
380 400 450 220 300 90 | 92 67 551 121 79 410

The first thing they will want to do is too look at the (using the `-` verb) differences between what their model predicted and what happened. This can be done easily by doing:

```{}
 predict:(150 100 110 190 80 70;300 100 50 200 330 500;250 120 100 80 80 110;360 400 500 520 350 420;380 400 450 220 300 90)
 real:(141 188 111 87 82 97;321 306 352 403 497 72;118 283 397 424 411 120;43 91 187 306 318 301;92 67 551 121 79 410)

 real - predict
(-9 88 1 -103 2 27
 21 206 302 203 167 -428
 -132 163 297 344 331 10
 -317 -309 -313 -214 -32 -119
 -288 -333 101 -99 -221 320)
```

In many more traditional programming languages (C, Pascal, Python (without Numpy)) performing an operation on two arrays like the one above requires a nested loop, something like like this (in Pascal):

```{}
DO UNTIL I=5
  DO UNTIL J=6
    DIFF(I,J):=ACTUAL(I,J)-FORECAST(I,J)
  END
END.
```

Even if this may seem obvious to a programmer, it is worth noting that most of the code has
nothing to do with the user requirement. The only important thing (subtract forecasts from
actual values) is hidden behind the detailed workings of the computer program.
To have a calculation done by a machine, one must translate our human wording into
something that the computer can understand. With traditional languages, most of that effort is
made by the man, to produce a program like the PASCAL example above. The great
advantage of APL is that the man has generally much less effort to make, and the machine
does the rest.

We have seen that APL will work on two variables of the same shape; it also works if one of the variables is a single item, which is called a scalar. If so, the other variable may be of any shape.

For example, let's say that a government try to reduce vehicle emissions decides to institute a tax based on fuel efficiency categories. The tax increases from 17.2 percent at the lowest (for 30 mpg and above) up to 33.2% for the worst mpg category, increasing by 4% at each step. The law makers used K to quickly work this out:

```{}
 tax:4 (4+)\17.2
 tax
17.2 21.2 25.2 29.2 33.2
```

If we want to calculate the amount of total tax applied to the cars above, we need to use `tax`, `number`, and `value` above:

```{}
 value:20 27 29 19 22 
 number:2 4 5 6 3
 tax:4 (4+)\17.2
 +/ (tax % 100) * number * value
121.516
```

That's 122 thousand of total tax on those 20 cars!




### More verbs

Most programming languages represent only a very small subset of the mathematical functions using symbols (typically `+`, `-`, `*` and `/`). The creator of APL, Ken Iverson, chose to include many traditional mathematical symbols in his language, but since, K reverts back to the more easily-accessible ASCII character set, but they're not all what you'd necessarily expect. As we've already seen, `%` is the verb for division and `\` is for comments.

Many programming languages have their own numerical programming library with functions like "square root" and "floor" that you have to import. In K, "shape" and "floor" have their own verbs. The monadic verb "sqrt" (`%`) returns the object's square root and the monadic verb "floor" (`_`) returns the floor vector (nearest integer) for a vector:

```{}
 predict:(150 100 110 190 80 70;300 100 50 200 330 500;250 120 100 80 80 110;360 400 500 520 350 420;380 400 450 220 300 90)
 % predict
(12.2474 10 10.4881 13.784 8.9443 8.3666
 17.3205 10 7.0711 14.1421 18.1659 22.3607
 15.8114 10.9545 10 8.9443 8.9443 10.4881
 18.9737 20 22.3607 22.8035 18.7083 20.4939
 19.4936 20 21.2132 14.8324 17.3205 9.4868)
 
 _ 1.1 9.8 5.6 -0.2 7.3 -1.5
1 9 5 -1 7 -2
```

Though you might have assumed otherwise, there isn't also a monadic verb for "ceiling", probably because you can simply use 1 + floor: `1+_`

```{}
 1+_ 1.1 9.8 5.6 -0.2 7.3 -1.5 
2 10 6 0 8 -1
```

In total, K6 has ~20 verbs, a number that's debatable, as many (all) have more than one meaning depending on the context.


### Most verbs have two meanings (at least!)

We've already used the terms *monadic* and *dyadic*. Even if you haven't seen these terms before, you almost certainly know what they mean. This is not a peculiarity of APL; in algebra we are familiar with the use of symbols as common as the minus sign being used in two different ways.

$$
\begin{aligned}
& \text{monadic: } \quad a = -y      \quad  \text{the minus sign indicates the negation of y} \\
& \text{dyadic:}  \quad\quad a = x - y   \quad  \text{the minus sign means subtract} \\
\end{aligned}
$$

The first form is called the "monadic" use of the verb. The second form is called the "dyadic" use of the verb. They have entirely different meanings. So to, in K, we have `-` meaning minus and negate, and `*` meaning times and first (as in it yields the first value of an array), depending on context.

```{}
  price
4.18 5.99 1.23 9.09 12.02

  forecast
(150 100 110 190 80
 300 100 50 200 330
 250 120 100 80 80
 360 400 500 520 350
 380 400 450 220 300)

  # price
5

  # forecast
5                            / So... what happened?
```

To understand why asking for the count of a 5x5 matrix would result in a `5`, you need to understand the definitions of atoms, vectors, and matrices in K:

- atoms are ncif(name char int float) and mdhrst(month day hour min sec milli)
- vector is unitype list of atoms, e.g. (2;3) is 2 3 and ("a";"b") is "ab"
- matrix is uniform list of vectors, e.g. m:(0 1 2;1 2 3)

That third definition is the answer to the seemingly odd result: `forecast` is composed of a list of 5 vectors, and thus its "count" is 5. 
So, unlike in its ancestor APL, in K you are unable to simply use `rho` to obtain the shape of a matrix.

In K, if you want a clearer picture of the count, shape, or size of `forecast`, you can do this:

```{}
 #:'predict
6 6 6 6 6                 / that is, forecast is five lists of count five
```

This works by adding two symbols to the `#` (count) we saw before. These are, simply, apply (`:`) and each (`'`). Combined, *count* is *applied* to *each*, or `#:'`. In this case, count is applied to each vector within the matrix (or list of lists) `forecast`. 

If you apply this to our `tax` variable, you will see that it yields an error, because the list is of rank one already.

```{}
 #:' tax  / note: behavior differs from oK 
#:' tax
^
rank error
```

Used dyadically, the same symbol will organise items into a specified shape. For example, suppose that we want to create the matrix below:

```
12 16
55 93
19 71
34 43
```

We must give the computer two pieces of information:
 - first the shape to give to the matrix: 4 2
 - next the contents of the matrix: 25 60 33 47 11 44 53 28
(4 rows of 2 columns)
It is the symbol `#` which makes the connection between the shape and the contents:

```{}
 m:12 16 55 93 19 71 34 43 12 16 55 93 19 71 34 43
 
 4 2 # m
(12 16
 55 93
 19 71
 34 43)
```


### Reduction Unifies Traditional Notations

Perhaps you remember the variable `costs`:

```{}
8.36 23.96 8.61 99.99 12.02
```

So what must we do to work out the total? Mathematicians are creative people who long ago
devised the verb-adverb pair `+/`, always with a pretty collection of indices above and below, which
make it complex to understand and to type on a typewriter.
In K, the operation is written like this:

```{}
 +/cost
152.94
```

Simple isn’t it? This gives the total of all the items of the array.
You can read this as "Plus Reduction" of the variable `cost` .

To gain a better understanding of the process:

```{}
 +/ 1 5 8 2 6
22
 1 + 5 + 8 + 2 + 6 
22       
```

These are both valid in K, resulting in the same sum,

```{}
 */ 1 5 8 2 6
480
 1 * 5 * 8 * 2 * 6  
480         
```

these result in the same product,

```{}
 |/ 1 5 8 2 6
8
 1 | 5 | 8 | 2 | 6 
8           
```

and these result in finding the same maximum value in the vector (8). 

*Reduction*, represented by the adverb `/` , belongs to a special category of symbols called
Operators. All the other symbols are called Functions (addition,
subtraction, multiplication, maximum, shape, etc.).

The left argument of *Reduction* can be one of many of the K symbols, and it can also be the
name of a user-defined program. This may give you an idea of the generality and power of the
concept.
K contains 10 such powerful operators. If that is not enough, you can even write
your own operators, just like you can write your own functions!


### Let's Write Our First Programs

Imagine that we want to calculate the average of the following numbers:

```{}
val:22 37 41 19 54 11 34
```

- First, you must calculate the some of `Val`: `+/ Val` giving 218
- Second, calculate the number of values: `# Val` giving 7
- Finally, divide the first by the second:  `+/Val % #Val` giving 31.1429

As it is quite likely that we shall often want to make this sort of calculation, it is preferable to
store this expression in the form of a program.
In K we prefer the name defined function to the name "program".
Defined functions may be used in the same way as the built-in functions represented by
special verbs like `+ - * % #`..., which are called primitive functions.
To define a simple function like this one, here is the easiest way:

```{}
 am:{+/x%#x}
 am
{+/x%#x}

 am val                   / and then the function can be applied to Val
31.1429

 am 1 5 10                / or any other vector
5.3333
```

Where `am` is the program name and `x` is a generic argument which represents the array passed on the right. The special names `x`, `y` and `z` are implicit arguments to a function. If all three are present, the function takes three arguments. If only `x` and `y` are present, the function takes two arguments. If only `x` is present, the function takes one argument. The definition of the function is delimited by a set of curly braces `{` and `}` . For more complex functions it is also possible to use a text editor, but this is beyond the scope of this short introduction.



### Indexing

Returning to our vector of numbers `val : 22 37 41 19 54 11 34`

In order to extract the 4th item, we just write: `val[4]`. In many other programming languages one uses parentheses instead of brackets; this is not very different. What is new is that one can extract several items in one instruction.

```{}
 val
22 37 41 19 54 11 34
 val[2 4 6 4 4 0]      / you can extract the same value more than once
41 54 34 54 54 22
```

It's important to point out that, unlike APL, K's indexing starts at 0. The first item in `val` is, as shown above, obtained by using `val[0]`. Here's what happens if you go beyond the length of the vector:

```{}
 val[7]
0N
```

You get back `0N`, meaning nan in the context of a integer, where *NAN* means "not a number".

And of course, in the same way, one may modify one or more items of Val using their
indexes. Naturally, one must provide as many values as there are items to modify, or a single
value for all:

```{}
 val[3 5 1]:0
 val
22 0 41 0 54 0 34

 val[3 5 1]:365 7 24
 val
22 24 41 365 54 7 34
```

It is often necessary to extract the first few items from a list of values, for example the first 5.
Nothing could be easier:

```{}
 val[0 1 2 3 4]
22 24 41 365 54
```

But if one needs to extract the first 500 items from a long list, typing the integers from 1 to 500 would of course be very inconvenient.
This is why K uses `!`, which produces the set of the first n integers. Thus, instead of writing `0 1 2 3 4 5 6 7` , it is sufficient to write `!8`. For the previous example, instead of `Val[0 1 2 3 4]` you can use `Val[!5]`.

### Calculating Without Writing Programs

The employees of a small (15-person) company are divided into three hierarchical categories, denoted simply 1,
2, and 3. One assigns to two variables the salaries and the categories (`Cat`) of these employees; as
partly shown here:

```{}
  salaries:4225 1619 3706 2240 2076 1389 3916 3918 4939 2735 912 1567 3451 1490 2111
  cat:3 1 3 2 2 1 3 3 3 2 1 1 3 1 2
```

But the employees don't want to be earning that same salary forever. A rumour reaches us about their plans: They want a different percentage increase for each category, according to the following scale:

Category | Salary increase
---------|----------
1 | 8%
2 | 5%
3 | 2%

If the company implements these salary increases, how much will it cost the company?
First you can create a varible for the rate increases:

```{}
 rates: 8 5 2 % 100
 rates
0.08 0.05 0.02
```

The first employee is in category 3, so the rate that applies to him is:

```{}
 rates[2]            / remember, the third item has the index = two
0.02
```

It follows that the first 5 employees, being in categories 3 1 3 2 2 respectively, are entitled to
the following increases:

```{}
 rates[2 0 2 1 1]
0.02 0.08 0.02 0.05 0.05
```

More generally, the rates applied to all of our employees could be obtained like this:

```{}
 rates[cat-1]
0.02 0.08 0.02 0.05 0.05 0.08 0.02 0.02 0.02 0.05 0.08 0.08 0.02 0.08 0.05
```

Having the rates, one has just to multiply by the salaries to obtain the individual increases:

```{}
 salaries * rates[cat-1]
84.5 129.52 74.12 112 103.8 111.12 78.32 78.36 98.78 136.75 72.96 125.36 69.02 119.2 105.55
```

Finally, by adding them all, one will know how much it will cost the company:

```{}
 +/ salaries * rates[cat-1]
1499.36
```

You may note that:

 - The expression remains valid whatever the number of employees or categories,
 - The result has been obtained without writing any program,
 - And this expression can be read as the simplest possible English, like this:
Sum the Salaries multiplied by Rates according to Categories

Clever, no?

This illustrates how the expression of a solution in APL can be very close to the way that the
solution could be phrased in everyday language. This also shows clearly that the ways of
reasoning induced by traditional programming languages are not the only possible ones. This
difference and originality, introduced by APL, are among the major features of the language.


### Friendly binary data

APL makes much use of binary data. It is most often created by means of relational functions
like = or > , which give the answer 1 or 0, depending whether the relation is true or not:

```{}
 salaries > 3000
1 0 1 0 0 0 1 1 1 0 0 0 1 0 0

 real > predict
(0 1 1 0 1 1
1 1 1 1 1 0
0 1 1 1 1 1
0 0 0 0 0 0
0 0 1 0 0 1)
```

K has several relational functions:

`<`, `>`, `=`, and `~`, with pretty self-explanatory results:
```{}
 2 3 5<1 0 6
0 0 1
  2 3 5>1 0 6
1 1 0
  3 4 6=6
0 0 1
  (`a;2 3 4)~(`a;2 3)
0
  (`a;2 3 4)~(`a;2 3 4)
1
```

**introduce symbols** (``a`) **here**


Each give binary output. Naturally one can operate on this binary data using all the functions of Boolean algebra, and
moreover, the symbols used are those familiar to mathematicians of all nationalities around
the world:

 - The function *AND* is represented by `&` 
 - The function *OR* is represented by `|`
 
Note that we've already defined the functionality of `&` and `|` in terms of maximum and minimum, in this context they function differently:

```{}
 (cat = 3) & (salaries < 4000)
0 0 1 0 0 0 1 1 0 0 0 0 1 0 0
 (cat = 3) | (salaries < 4000)
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```

In fact APL offers all the functions of Boolean algebra, including some perhaps less familiar functions like NOR and NAND (Not-OR and Not-AND), but they are very useful in finance and electronic automation. Simply put `~`, meaning *NOT*, in front of the expression. This works the same with *equal* and *not equal*, which can be used as a XOR (Exclusive-OR).

```{}
 (cat = 3) & (salaries < 4000)
0 0 1 0 0 0 1 1 0 0 0 0 1 0 0
 ~ (cat = 3) & (salaries < 4000)
1 1 0 1 1 1 0 0 1 1 1 1 0 1 1
```

#### Counting

With this imformation, you can, of course, combine functions. Suppose you want to quickly determine how many employees earn more than 3000, but less than 4000:

```{}
 +/ (salaries > 3000) & (salaries < 4000)
4
```

#### Selection

One can also use the binary vector as a "mask" to select the items corresponding to the binary
"1"s from another array:

```{}
 & 1 2 3 4 5 6 ! 1 0 0 1 1 0
1 4 5

 & "abcdef" ! 1 0 0 1 1 0       / and for character data 
"ade"
```

This function, called *Compress*, is particularly useful for extracting the items conforming to a
given criterion from a variable. For example, to display the salaries of people in Category 2,
one writes:

```{}
 & salaries ! (cat = 2)
2240 2076 2735 2111
```


#### Discovery

To practise our skills some more, let us find in our variable Val the positions of numbers
greater than 35. Here are the necessary steps:

```{}
 val:22 37 41 19 54 11 34
 val > 35
0 1 1 0 1 0 0
 #val
7
 !#val
0 1 2 3 4 5 6
```

You can see that that if you eliminate (using *Compress*) the items which correspond to zeros
in order to retain only those corresponding to 1, you easily get the positions required: 2 3 5
Thus the job may be done as follows:

```{}
 & val>35
1 2 4
```

This expression is applicable in many different situations.Here is a similar use, but applied to character data: To find the positions of "a" within a phrase; the method is the same.

```{}
 phrase:"Panama is a canal between Atlantic and Pacific"

 & phrase = "a"
1 3 5 10 13 15 29 35 40
```




### A touch of modern math

Touch of Modern Math
Proudly having found all the "a"s, we may wish to find all the vowels.
Alas, although we can write Phrase = 'a' , because a vector can be compared with a single
value, one cannot write Phrase = 'aeiouy' (1) , because that would require the item by item
comparison of a phrase of 46 letters and "aeiouy" which has only 6.
In other words: You may compare 46 letters with 46 other letters, or compare them with one
letter, but not with 6.
So we shall use a new function: Membership which is represented by the symbol  , also used
in mathematics.(  can be obtained by pressing Ctrl +E)
The expression A  B returns a Boolean result which indicates which items of the variable A
appear in the variable B , wherever they may be. And it works no matter what are the shapes,
the dimensions or the type (numeric or character) of A and B , a pure marvel!
For example:

```{}
  5 7 2 8 4 9 in 3 4 5 6
1 0 0 0 1 0

  3 4 5 6 ? 5 7 2 8 4 9  / similar, but not the same
2 4 4 4 1 4

 "laptop" in "school bus"
1 0 0 0 1 0
```

Similarly, you can find the location of every vowel within `Phrase`, with this simple expression:

```{}
  & phrase in "aeiou"
1 3 5 7 10 13 15 19 22 23 29 32 35 40 42 44
```

One can also use membership between a vector and a matrix, as shown below, assuming that
the list of towns is a variable created earlier.
We have represented side by side the variable itself and the result of using Membership:

```{}
 towns:("Canberra";"Paris";"Washington";"Moscow";"Martigues";"Mexico")
 towns in "aeiou"
(0 1 0 0 1 0 0 1
 0 1 0 1 0
 0 1 0 0 1 0 0 0 1 0
 0 1 0 0 1 0
 0 1 0 0 1 0 1 1 0
 0 1 0 1 0 1)
```


### A powerful search function

We have harnessed a very useful method to look for the positions of letters or numbers in a
vector, but the answer obtained does not provide a one to one correspondence between the
search values and the resultant positions:

```{}
 list:15 40 63 18 27 40 33 29 40 88
 at:29 63 40 33 50
 & list in at
1 2 5 6 7 8
```

The positions are correct, but 29 is not in position 2, and 40 is not in position 6.
The question we have answered using the expression above is: "In which positions in List do
we find a number that also appears somewhere in Where ?"
If we want to answer the slightly different question: "Where in List do we find each number
in Where ?" we need to use a different method.
This new method uses the dyadic form of the symbol `?`. Where `?` means *find*.

```{}
 list ? at
7 2 1 6 10
```

It is true that 29, 63, 40 and 33, occur respectively in positions 8, 3, 2 and 7. It's much better!
But, first surprise: The value 40 occurs 3 times in List , but only the first one is reported in
the result. This is because, by definition, dyadic Iota returns only the first occurrence of a
given item. If the response for each value sought has to match a position; how may one,
looking for 5 numbers, obtain 7 results?
Second surprise: The value 50 is reported as being found in position 11 in a vector comprising
only 10 items! This is how the function IndexOf (dyadic `?` ) reports that a value is absent.
At first sight this seems a bit surprising, but in fact it is a property which makes this function
so generally powerful, as we shall soon see.

#### An example

A car manufacturer decides that he will offer his customers a discount on the catalogue price
(you can see how this example is imaginary!)
The country has been divided into 100 areas, and the discount rate will depend on the area
according to the following table:


Area | Discount
-----|---------
17 | 9%
50 | 8%
59 | 6%
84 | 5%
89 | 4%
----|----
Others | 2%

The problem is to calculate the discount rate that may be claimed for a potential customer who
lives in given area *d*; for example *d:84*.

Let's start by creating two variables, based on the table, and then see if 84 is in the list of favored areas:

```{}
area:17 50 59 84 89
discount:9 8 6 5 4 2

 d in area
1               / it's there!
 area ? d
3               / and 84 is the 4th item
```

Let us find the current rate of discount for this index position:
```{}
  discount[3]
5  
```

So the customer can claim a 5% discount! Another way to write this is to simple do: `Discount[Area?D]`.
If a customer lives in any area such as 75, 45, or 93, the expression `Area?D` will in all cases
give the result 6, because those values are absent in `Area` . Then `Discount[6]` will always
find the rate 2%, as expected.
The importance of this approach is that it is vector-based. Suppose that publicity attracts
crowds and that therefore `D` is no longer a single value but a vector, the solution is still valid:
```{}
 d:24 75 89 60 92 50 51 50 84 66 17 89
 discount[area?d]
2 2 4 2 2 8 2 8 5 2 9 4
```

All that without a program, neither "loop" nor "test", and whatever the number of areas.
Readers who know other programming languages will have no difficulty in making the
comparison.

#### Generalization

In truth, the expression we just wrote is an example of an algorithm for "changing the frame of
reference". Don’t panic, the name may seem esoteric, but the concept is simple. A list of area
numbers (the initial set) is translated into a list of discount rates (the final set).
Let us now imagine the initial set to be an alphabet composed of lower case and upper case
letters, and the final set to be composed of only upper case letters (with a blank space in the
middle):

```{}
 alphaL:"abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 alphaU:"ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ*"
```

Notice that `alphaU` is one character longer than `alphaL`. We have added an asterisk
at the end, and you will see why we did so:
Here is a little French sentence, with one accented letter. The expression below converts from lower to upper case.

```{}
 tale:"Le Petit Chaperon-Rouge a bouffé le Loup"

 alphaU[alphaL?tale]
"LE PETIT CHAPERON*ROUGE A BOUFF** LE LOUP"
```

As one might expect, the characters – and é , which are absent from the initial alphabetic set
have been replaced by the * of the final set, but the conversion is acceptable. This solution can
easily be improved.
Once more, the rational steps to be taken to create a solution are easily translated into a
programming algorithm, and the programmer can thereby get a much more extensive insight
into the problem itself.

### After Values, Let Us Process Shapes

Many traditional programming languages do not really handle arrays of numbers or
characters. They hold them in memory, but when the arrays are required for processing they
can only be handled one item at a time. It is not surprising in these circumstances, that these
languages have only limited means of controlling the shape of the data.
It is quite the opposite in APL, which offers many tools for working with the shape of the
data. We shall only look at a few of them here.




#### Take and drop

The functions *Take* (`#`) and *Drop* (`_`) serve, as their names suggest, to extract part of a set of
values. Here we shall show only examples based on vectors, but all the other shapes of data
can be treated in a similar way.

Recalling that `list` has values `15 40 63 18 27 40 33 29 40 88`

```{}
 4 # list
15 40 63 18
 5 _ list
40 33 29 40 88
```

If the left argument is negative, these same functions count from the end of the vector.

```{}
  -3 # list
29 40 88
  -7 _ list
15 40 63
```

That last result is the same as obtained by `3 # list`.

Several pages ago, we used `val[!5]` to extract the first 5 items of `Val`. We can now see
that we also could have used `5#val`.


Here again, using these new symbols, it is possible to create innovative solutions to classical problems. Let us imagine a business with a turnover which has grown over 12 years. The variable `Tome` is Turnover in millions of euros.

```{}
tome:56 59 67 64 60 61 68 73 78 75 81 84
```

We want to calculate the difference between each year and the year before; how can we do it?

```{}
  1_tome
59 67 64 60 61 68 73 78 75 81 84
  -1_tome
56 59 67 64 60 61 68 73 78 75 81
```

In other words, in each position of the first result we have "this year's turnover", and in the
same position in the second result we have "the previous year's turnover".
We see that all that remains is to subtract these results item by item:

```{}
  (1_tome)-(-1_tome)
3 8 -3 -4 1 7 5 5 -3 6 3
```

In place of a subtraction, a division would calculate (with some obvious adjustments) the rates of growth instead of the differences:

```{}
  100*((1_tome)%(-1_tome))-1
5.3571 13.5593 -4.4776 -6.25 1.6667 11.4754 7.3529 6.8493 -3.8462 8 3.7037
```

Let us put that in a small defined function, and apply it:


```{}
  growth:{100*((1_x)%(-1_x))-1}
  growth tome
5.3571 13.5593 -4.4776 -6.25 1.6667 11.4754 7.3529 6.8493 -3.8462 8 3.7037
```


#### Mirrors and Transposition

APL is also well equipped with functions to pivot data about any axis, as suggested by the
appearances of the symbols used. They apply to both numeric and character data; as we are
going to show by applying these functions to the variable `Towns` that we used earlier.

```{}
  towns:("Canberra";"Paris";"Washington";"Moscow";"Martigues";"Mexico")
```

Using `Towns`, here's how you mirror and transpose in K:
 
 - top-bottom reverse: `|`
 - left-right reverse: `|:'`
 - swap rows & columns: `+`
 
Here's the results:

```{}
 |towns
("Mexico"
 "Martigues"
 "Moscow"
 "Washington"
 "Paris"
 "Canberra")
 
 |:'towns
("arrebnaC"
 "siraP"
 "notgnihsaW"
 "wocsoM"
 "seugitraM"
 "ocixeM")
 
 +towns    / transpose doesn't work in some k versions, but works in oK
("CPWMMM"   / is allowed if all vectors are of equal length
 "aaaoae"
 "nrssrx"
 "bihcti"
 "esioic"
 "rPnwgo"
 "ragMuM"
 "artoee"
 "Ciossx"
 "asncMi")

```

Note that when using `+` to transpose the matrix (a list of vectors in K), each vector wraps around to match the length of longest vector; in the case of `towns` it's "Washington".

### Back to primary school

Remember when we learned our multiplication tables? In that practically Palaeolithic era, to
make sure that we knew all our tables, my teacher made us calculate the multiplication table
for the integers 1 to 9:


x || 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
--|--|--|--|--|--|--|--|--|--|--|--
1 || 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
2 || 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18
3 || 3 | 6 | 9 | 12 | 15 | 18 | 21 | 24 | 27
4 || 4 | 8 | 12 | 16 | 20 | 24 | 28 | 32 | 36

You see, I haven’t forgotten!
Probably you have done all this just like me. And then we quickly forgot that very powerful
tool, one which APL provides under the name *Outer Product*.

The task consists of taking all possible pairs of items of two vectors, (the column and row
headings) and making them the left and right arguments of the function at the top left. For
example, 3 times 7 gives 21 (in red here above).
Next we shall go on to see what we get if we change the values a little:


x || 8 | 5 | 15 | 9 | 11 | 40
--|--|--|--|--|--|--|--|--|--|--|--
5 || 40 | 25 | 75 | 45 | 55 | 200
4 || 32 | 20 | 60 | 36 | 44 | 160
10 || 80 | 50 | 150 | 90 | 110 | 400
3 || 24 | 15 | 45 | 27 | 33 | 120

This operation is written as follows in K:

```{}
 5 4 10 3 *\: 8 5 15 9 11 40
(40 25 75 45 55 200
 32 20 60 36 44 160
 80 50 150 90 110 400
 24 15 45 27 33 120)
```

The *Outer Product* is composed of the multiplication `*` symbol, and the *eachleft* `\:` function, where you apply the dyad to each left argument and the entire right argument, producing a new list of products.

Despite of its name *Outer Product* this operator is by no means restricted to working with
multiplication. We can replace the symbol for multiplication (`*`) by any other dyadic function
(like `+`, `<`, `>`, or `|` ), or even functions which you have defined yourself, and you
will understand, as for Reduce which we saw earlier, that Outer Product is an operator of
amazing power.

Let’s have some fun with it:

```{}
 (!5) =\: (!5)
(1 0 0 0 0
 0 1 0 0 0
 0 0 1 0 0
 0 0 0 1 0
 0 0 0 0 1)

 (!5) <\: (!5)
(0 1 1 1 1
 0 0 1 1 1
 0 0 0 1 1
 0 0 0 0 1
 0 0 0 0 0)

  (!5) |\: (!5)
(0 1 2 3 4
 1 1 2 3 4
 2 2 2 3 4
 3 3 3 3 4
 4 4 4 4 4)
```

#### A useful application

Suppose the vector Ages contains the ages of 70 respondents to an opinion poll. We want to establish how many people there are in each of the following categories:

0 - 25 - 30 - 35 - 45 - 50 - 55 - 65 or above. Here is an extract of the data:

```{}
ages:51 45 28 72 75 87 50 9 48 48 76 47 95 74 75 83 34 22 18 70 90 23 77 74 19 81 7 8 68 92 15 
81 16 58 85 26 70 11 14 84 35 58 84 19 81 45 67 20 42 0 27 42 84 59 97 54 4 56 24 30 31 78 72 
83 78 30 92 58 59 54

category:0 15 30 45 60 75 90
```

We are going to use the *Outer Product* `ages >\: category`. This results in a largre boolean matrix. If one adds up this Boolean matrix, one obtains for each row the number of people who are older than 0 years, older than 25 years, older than 30 years, etc. This is the expression:

```{}
 totals:+/ ages >\: category
 totals
69 62 49 42 29 19 4
```


With the cut-down extract shown above, the value of cum would be: `69 62 49 42 29 19 4`. In other words there are 69 people older than 0 (yes, if you go back to `ages`, you'll see a 0-year-old). But among them, 62 are older than 15, and so on through the catgories. But, in order to know how many people are between, say, 25 and 30, it is necessary to subtract 62 from 69 to obtain 7.

If one wants to reproduce this calculation for all categories, this is all you need to do:

```{}
  totals-(1_totals,0)
7 13 7 13 10 15 4
```

To append a zero to the right, we used a comma, which joins variables together. This is a
function called Catenate.

All that without real programming, and it works whatever the number of people or categories.
What luck!

Once again, K allowed us to find straightforward and original solutions to traditional
problems.







































 



\newpage




# Chapter 2: Data and variables

When you use APL, you type an expression or a command into the session window, and the
result of the expression, or a message resulting from the execution of the command, is
displayed starting on the next line. So an APL “session” is a sequence of user input lines
(expressions and/or commands) interleaved with the results of the expressions.
To help you see what you have done, APL initially positions the input cursor 6 spaces in from
the left margin. Unless you deliberately move the cursor before you start typing, the
expressions you enter into the system will therefore be indented, whereas the results of the
expressions will not. For further clarity in this document, user input appears in red.
It is recommended that you go through this tutorial in front of your computer, and experiment
by typing the expressions given below into the Dyalog session window. Try changing the
expressions, and observe the new results.




## 2.1 Simple numeric values

### Our first operations

Let's try some simple expressions (press Enter to have each expression evaluated):

```{}
  27 + 53
80
  1271 - 708
563
  644 - 832
-188  
  86 % 4
21.5
  59 * 8
472
```

If you are familiar with other programming languages, you may be accustomed to using a
slash (`/`) for division. Let's see what might happen if you mistakenly use `/` in K:

```{}
  9 / 2
9
```

`/` is, at least in this situation, interpreted to be a comment, so all K evaluates is the 9.

### Variables

As in any other programming language, it is possible to create variables. Just choose a name
and use the assignment symbol (`:`) to assign it a value. The value can be a single item or
several items separated by spaces.

```{}
Discount:0.15
Years:1952 1943 1956 2007
Purchase:4000
```

To obtain the value of a variable, simply type its name and press the *Enter* key:

```{}
  Discount
0.15
  Years
1952 1943 1986 2007
```

Variable names are *case sensitive*, as in many programing languages. If you misspell, or type a character in the wrong case, an error message will be displayed if that name is unknown:

```{}
  discount
the name 'discount' has not been defined.
```

(The error message may differ depending on the K REPL that you're using, but you get the point.)

Variable names must follow certain rules:

 - They must contain only letters, in lower or upper-case, including some accented letters (cf.
below), and the digits (0 to 9).
 - The APL alphabet also includes the Greek letter Delta, entered using Ctrl+H , the
Underscore sign ( _ ), and also the Underscored Delta, entered using Ctrl+. (dot).
 - They cannot start with a digit.

### Operations on variables

Variables can be used in any expression. For example if we want to find the number of people earning salaries (`Earners`) at our company, we can write:

```{}
 salaries
4225 1619 3706 2240 2076 1389 3916 3918 4939 2735 912 1567 3451 1490 2111
 #salaries
15
 earners:#salaries
```

When the result of an expression is assigned to a name, it is not displayed. If the result of an operation is
not assigned to a name, it is immediately displayed, but then the value of the result cannot be
reused in another expression. It is possible to overwrite the contents of a variable by:

```{}
 earners:15
 earners
15
```











## 2.2 Arrays of Items

### Create a list or a matrix

In K, storing a short list of items in a variable is as simple as:
```{}
 example:91 22 30 33 95 87 54 11
91 22 30 33 95 87 54 11
```

Imagine now that somebody has noted his income and expenses during the first six month of
this year:

Month | Income | Expenses
------|--------|---------
Jan   | 4121   | 2983
Feb   | 1241   | 9129
Mar   | 9643   | 3349
Apr   | 5031   | 4532
May   | 4517   | 6823
Jun   | 9812   | 5378

We shall see later how we can store the names of the months; for now, let us just try to store
the numeric values from the above table in a variable.
To do this, we have to give two pieces of information to the computer:

 - The shape of the array: in this case, 6 rows and 2 columns
 - The contents (or items) of the array, in row order.
The function that organises a set of items into an array of a specified shape is known as
Reshape and is symbolised by the Greek letter Rho. It is easy to remember that Rho can
be entered using Ctrl-R

The **Reshape** function is used as follows: R: *Shape* `#` *Contents*
For example, to obtain a 4 by 2 array of items:

```{}
example:91 22 30 33 95 87 54 11

  4 2 # example
(91 22
 30 33
 95 87
 54 11)
```


### Special cases with reshape

If there are too few items in the vector, the matrix wraps around. If there are too many items in the vector, the extra itmes are ignored:

```{}
 5 2 # Example
(91 22
 30 33
 95 87
 54 11
 91 22)

 3 2 # Example
(91 22
 30 33
 95 87)
```

### Multi-dimensional arrays

K is not limited to arrays with two dimensions, it can handle arrays with 3, 4, indeed up to
15 dimensions.
Imagine that a company has stored the production of its assembly lines in a variable named
`Prod`.
The variable contains 5 years of production, on 2 assembly lines, and for 12 months per year.
To represent the 3 dimensions on the screen, the array is displayed split into sub-arrays each
representing a single year, as follows:

```{}
  prod: 26 16 22 17 21 44 25 22 23 44 41 33 43 36 47 49 30 22 57 20 45 60 43 22 44 21 58 
57 17 43 47 17 43 26 53 23 29 19 23 38 53 47 38 22 40 57 35 26 37 27 53 26 29 46 25 26 30 
20 32 16 56 55 25 47 38 27 39 59 20 28 42 25 21 57 55 44 16 54 26 16 55 56 45 45 16 55 26 
20 27 55 36 39 43 38 50 16 27 23 56 41 53 60 39 47 44 47 17 28 24 35 61 26 22 35 24 20 31 
35 47 37

  prod:5 2 12 # prod
  prod
((26 16 22 17 21 44 25 22 23 44 41 33
  43 36 47 49 30 22 57 20 45 60 43 22)      / parens separate sub-arrays; year 1
 (44 21 58 57 17 43 47 17 43 26 53 23
  29 19 23 38 53 47 38 22 40 57 35 26)      / year 2
 (37 27 53 26 29 46 25 26 30 20 32 16
  56 55 25 47 38 27 39 59 20 28 42 25)      / year 3
 (21 57 55 44 16 54 26 16 55 56 45 45
  16 55 26 20 27 55 36 39 43 38 50 16)      / year 4
 (27 23 56 41 53 60 39 47 44 47 17 28
  24 35 61 26 22 35 24 20 31 35 47 37))     / year 5
```

This array is organised in dimensions that represent 5 years, 2 lines, 12 months: it is a three
dimensional array. We can also say that its *shape* is `5 2 12`.






 








## 2.3 Shape, Rank, and Vocabulary

### Shape and Rank

The symbol `#`, which we introduced above, can be used to obtain the lengths of the
dimensions or the *Shape* of an array. 

```{}
  #:' prod        
2 2 2 2 2

  #:'' prod
(12 12
 12 12
 12 12
 12 12
 12 12)
```

### Scaling down the ranks

### Vocabulary

### Beware!

#### The shape is always a vector

The shape of a value is always a vector, even if it contains only one item or even no items at
all.

#### Do not rely on the visual aspect of a variable

#### Displaying long vectors






 








## 2.4 Simple character values

### Character vectors and scalars

Up to now, we have used only numeric values, but we can also create textual data known as a
character array. To identify a string of characters as text, we start and end it with a single
Quote:

```{}
 text:"Today is August 14th, 2007"
"Today is August 14th, 2007"

  #text
26  

 trailer:"I type 7 trailing blanks       "
"I type 7 trailing blanks       "

 #trailer
31
```

As these examples show:
 
 - The quotes are not part of the text, they're just there to delimit it.
 - Text can include any character: letters, digits, punctuation.
 - So, Text and Trailer are vectors. They are sometimes called Strings.
 - K does not recognize words; a character array is simply a set of characters.
 - Blank characters (spaces) are characters like any other characters; they do not have any
special meaning. However, when a character array is displayed any trailing blanks are
most often invisible.

As mentioned above a character array can contain digits, but they are not considered to be
numbers, and it is impossible to use them in a mathematical operation:

```{}
  Hundred:"100"  / looks like a number
"100"
  #Hundred       / it's actually a vector of size three
3
  Hundred + 0    / but why did this happen?
49 48 48
```

For that last result, why would adding a string (`"100"`) to 0 equal `49 48 48`?

In K, all strings are encoded as ASCII characters. When mathematical opertaions are performed on strings, their underlying ASCII codes are used. So, as you can probably infer (if you haven't memorized the ASCII code table), 49 is the ASCII code for "1" and 48 is the ASCII code for "0".



### Character arrays

We saw, some pages ago, a list of months:
```
   January
   February
   March
   April
   May
   June
```

We can think of this as a list of 6 words, or as a matrix of 6 rows and 8 columns (the width of
"February"). Both representations are valid, and both can be used in APL; let us study them
one after the other.
To enter the months as a 6 by 8 matrix, one must use the `Reshape` (`#`) function:

 - To the left of the function we must specify the shape of the matrix we want to build: `6 8`
 - To the right of the function we must specify all of the characters (including any trailing
blanks) that are necessary to fill each row to the proper length:

```{}
  MonMat: 6 8 # "January FebruaryMarch   April   May     June    "
 #MonMat
6             / 6 vectors
 #:'MonMat
8 8 8 8 8 8   / 6 vectors of size 8
```

But this method of padding with spaces is somewhat inconvenient. Here is a better method.

To enter the months as 6 words, one must type each word between quotes, and check that
each closing quote is separated from the next opening quote by at least one blank (otherwise it
would be interpreted as an apostrophe – remember, the juxtaposition of two quotes in a
character string is used to enter a single quote):

```{}
  MonVec:("January";"February";"March";"April";"May";"June")
 # MonVec
6
 #:' MonVec
7 8 5 5 3 4
```

In K, since matrices are simply lists of vectors, there is almost no point in padding to make vectors of equal length.

`MonVec` is a vector of a kind that we have not seen before, the items of which are 6 sub-
arrays. This kind of an array is called a `Nested Array`.
Be patient! We shall study nested arrays very soon in this very chapter.







 






## 2.5 Indexing

### Traditional vector indexing

Our variable Contents contains the following items:

``` 12 56 78 74 85 96 30 22 44 66 82 27 ```

To extract one of these items, you just have to specify its position, or Index, between Square
brackets:

```{}
  Contents[2]
78  
```

In most "traditional" languages, programmers generally use parentheses instead of brackets,
but parentheses have many other different uses. In K, parentheses have one and only one
use, namely to specify the order of evaluation of a complex expression. In this respect, the use
of square brackets for indexing makes K more rigorous.

Of course, an index must follow some obvious rules: it must be an integer numeric value; it
may not be negative or greater than the size of the vector. Otherwise, an **" INDEX ERROR "** will
be reported.

It is possible to extract several items in a single operation, and in any order:

```{}
  Contents[3 7 1 3 3 11]
74 22 56 74 74 27

```

The same notation allows you to modify one or more items of the vector. The only condition
is that you must provide as many replacement values as the number of items you select, or
give a single replacement value to use for all the selected items:

```{}
  Contents[2 4 6]: 7 11 80
12 56 7 74 11 96 80 22 44 66 82 27

 Contents[1 7 9]: 33                 / a single value replaces three items
12 33 78 74 85 96 30 33 44 33 82 27
```

This works exactly the same on character vectors:

```{}
 "this is pretty awesome isn't it?!"[13 10 3 4 2 0 4 2 3 32]
"yes it is!"
```

### The shape of the result

The index may be a numeric array of any shape: scalar, vector, matrix, or an array of higher
rank. To understand what happens, there is a simple rule:

> When a vector is indexed by an array, the result has exactly the same shape as the index
> array, as if each item of the index had been replaced by the item it designates.

This rule is easy to verify. Let us restore the initial values of `Contents`:

```{}
  Contents:12 56 78 74 85 96 30 22 44 66 82 27
12 56 78 74 85 96 30 22 44 66 82 27
```

And let's create a matrix of indices:

```{}
  MyIndex:3 5 # 4 4 3 3 7 5 11 5 10 11 9 5 0 3 8
(4 4 3 3 7
 5 11 5 10 11
 9 5 0 3 8)

  Contents[MyIndex]
(85 85 74 74 22
 96 27 96 82 27
 66 96 12 74 44)
```

The rule remains true if the indexed vector is a character vector. For example, imagine that we
have a matrix named `Planning`, in which some tasks are planned (1) or not (0) over the next
12 months:

```{}
  Planning: 5 12 # 0 0 0 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 0 0
  0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0 0 0 0
(0 0 0 1 1 1 1 1 1 0 0 0
 1 1 1 1 1 1 1 1 0 0 0 0
 0 1 1 1 0 0 0 0 0 1 1 1
 0 0 0 0 0 0 0 1 1 1 1 1
 0 0 1 1 1 1 1 0 0 0 0 0)
```

Let us replace the inactive periods by "-", and the busy periods by "O".

```{}
  "-O"[Planning]
("---OOOOOO---"
 "OOOOOOOO----"
 "-OOO-----OOO"
 "-------OOOOO"
 "--OOOOO-----")
```

Of course, the vector to be indexed was composed of only two characters, so the set of indices
had to be composed only from the values 1 and 2. This is the reason why we added 1 to
Planning .
All the 0's in Planning have been replaced by the 1st item ("-"), and all the 1's have been
replaced by the 2nd item ("O").

### Array indexing


Just to make some experiments, let us create a new variable, named `Tests`:

```{}
  tests:6 3 # 52 12 93 85 81 76 99 49 56 98 12 34 53 45 12 54 45 61
(52 12 93
 85 81 76
 99 49 56
 98 12 34
 53 45 12
 54 45 61)
```

Indexing an array is very similar to the method we saw for vectors, but we now need one
index for the row and one for the column; they must be separated by a Semi-colon. For
example, to get (or replace) the value 55 in row 4, column 3, one types:

```{}
  tests[2;2]
56                  / third row, third column

```


It is of course possible to select more than one row and more than one column. If so, one
obtains all the values situated at the intersections of the specified rows and columns.

```{}
  tests[1 2;1 2]
(81 76
 49 56)
```

The result of indexing may sometimes be surprising. Try extracting these four values from the first column:

```{}
  Tests[0 1 4 5; 0]
52 85 53 54
```

You probably expected the result to be displayed like a column? Really sorry!
The result of this expression is a vector, and a vector is always displayed as a row on the
screen.
We shall see later that it is possible, using a little trick, to cause the result to be displayed
vertically.
When you use indexing, you must specify as many indices or sets of indices as the array's
rank. For a 3-D array, you must specify 3 sets of indices, separated by two semi-colons.
For example, suppose that we would like to extract the production of the 2 nd assembly line, for
the first 6 months of the last two years, from the array `Prod`. Let's express that in the order of
the 3 dimensions: Years/Lines/Months:

 - The last two years are in positions `3 4`
 - The second assembly line `1`
 - The first six months `0 1 2 3 4 5`

```{}
  Prod[3 4;1;0 1 2 3 4 5]
(16 55 26 20 27 55
 24 35 61 26 22 35)
```

### Convention

To specify all the items of a dimension, you just omit the index for that dimension, but you
must not omit the semi-colon attached to it.
In the previous example, to obtain both assembly lines we could have typed:

```{}
  Prod[3 4;0 1;0 1 2 3 4 5]
((21 57 55 44 16 54
  16 55 26 20 27 55)
 (27 23 56 41 53 60
  24 35 61 26 22 35))

/ or you can do this, meaning all assembly lines

  Prod[3 4;;0 1 2 3 4 5]
((21 57 55 44 16 54
  16 55 26 20 27 55)
 (27 23 56 41 53 60
  24 35 61 26 22 35))

/ or this, meaning all the months (years four and five)

  Prod[3 4;;]
((21 57 55 44 16 54 26 16 55 56 45 45
  16 55 26 20 27 55 36 39 43 38 50 16)
 (27 23 56 41 53 60 39 47 44 47 17 28
  24 35 61 26 22 35 24 20 31 35 47 37))
```

This convention also applies to replacing specific items. For example, to change all the items
in the last row of Tests , we could type:

Of course, this convention for applying to entire rows also works for *replacing* items. For example, replacing the last row of `Tests`:

```{}
  Tests[5;]:11 22 33
(52 12 93
 85 81 76
 99 49 56
 98 12 34
 53 45 12
 11 22 33)

```

### Warnings

We would like to draw your attention to some delicate details. Here is the first:

#### Shape compatibility

To replace several items in an array, the replacement array must have exactly the **same shape**
as the array of indices they replace. For example, suppose that we would like to replace the four "corners" of `Tests` with the values `11 22 33 44` respectively.

We cannot successfully execute: `Tests[1 6;1 3]:11 22 33 44 `; a `"length error"` would be issued. If we had extracted these four values, the result would have been a 2 by 2 matrix:

```{} 
  Tests[0 5;0 2]
(52 93
 11 33)
```

So, to replace them, we cannot use a vector, as we have just tried to do. Instead we must
organise the replacement array into a 2 by 2 matrix, like this:

```{}
  Tests[0 5;0 2]:2 2 # 1 2 3 4        / Get incorrect behavior in oK, had to use Kx
(1 12 2
 85 81 76
 99 49 56
 98 12 34
 53 45 12
 3 22 4)

```


### The index function


In APL, nearly all of the built-in functions (known as Primitive Functions) are represented by
a single symbol: `+ * # %` etc. Bracket indexing, as we introduced above, is an exception: it is
represented by two non-contiguous symbols: `[` and `]`. This is one of the reasons why modern
versions of APL also include an Index function.
It is represented by the symbol `squish-quad`
Beware: This is not the symbol Quad used in our planning example a few pages ago!
In fact, it looks like a Quad which has been squished, hence its name: Squish-Quad, or Squad
for short.

When applied to a vector, Index takes a single number on its left.

```{}
 Ages @ 0          /equivalent to Ages[0]
51
```


















 




## 2.6 Mixed and nested arrays

Up to now we have dealt with only homogenous arrays: Scalars, vectors, or higher rank arrays
containing only numbers or only characters. An array was a collection of what we call simple
scalars. In the early 1980's enhanced versions of APL started to appear. They accepted a
mixture of numbers and characters within the same array (so-called Mixed Arrays), and arrays
could contain sub-arrays as items (so-called Nested Arrays).
In this chapter, we shall explore only some basic properties of Mixed and Nested arrays, just
to help you understand what might otherwise appear to be unusual behaviour or unexpected
error messages. We shall not go any further for now; Chapter I will be entirely dedicated to an
extensive study of nested arrays.
Note that with the current widespread use of Nested arrays, it is now very common to refer to
an "old-fashioned" array that is neither Mixed nor Nested as a Simple array.

### Mixed arrays

An array is described as a Mixed Array if it contains a mixture of scalar numbers and scalar
characters.
It is easy to create such an array:

```{}
 MixVec: 44, 87, "K", 12, 29, "8", "a", "g", 46.3
 MixVec
(44;87;"K";12;29;"8";"a";"g";46.3)
 #MixVec
```

You may have noticed that, unlike arrays of a single type, mixed arrays require commas between items (`,`).

```{}
 MixMat:2 5 # MixVec
 MixMat
(44 87 "K" 12 29
"8" "a" "g" 46.3 44)

```

### Nested arrays

An array is said to be Generalised or Nested when one or more of its items are not simple
scalars, but are scalars which contain other arrays. The latter may be simple arrays of any
shape or rank (vectors, matrices, arrays), or they may themselves be Nested arrays.
A nested array can be created in a number of ways; we shall begin with the simplest one,
known as Vector notation, or Strand notation. Here is how it works:
The items of an array are just juxtaposed side by side, and each can be identified as an item
because it is:

- either separated from its neighbours by ..........blanks
- or embedded within ...............................quotes
- or an expression embedded within .................parentheses
- or a .............................................variable name

Just to demonstrate how it works, let us create a nested vector and a nested matrix.

```{}
 One: 2 2 # 8 6 2 4
 One
(8 6
2 4)
 Two:"Hello"
 Two
"Hello"
 NesVec:(87; 24; "John"; 78 45 23; 51; 85; One; 69)
 NesVec
(87;24;"John";78 45 23;51;85;(8 6;2 4);69)
 #NesVec
8 

```

Notice how mixed-type lists are enclosed in () and each element should be separated by a semicolon. And, the 4th item contains three items: `NesVec[3]` results in `78 45 23`.

Now, nested matrices:

```{}
 NesMat:(2 3 # "matrix";44;Two;27;One;(2 3#1 2 0 0 0 5))
 NesMat
(("mat";"rix");44;"Hello";27;(8 6;2 4);(1 2 0;0 0 5))
 NesMat
 NesMat[5]
(1 2 0
0 0 5)
```










 



## 2.7 Empty arrays

An array is an empty array if the length of one or more of its dimensions is zero. Hence, it is
possible to meet many different kinds of empty arrays: vectors, matrices, arrays of any rank or
type.

 - `0#0`        empty numeric vector
 - `""`         empty character vector
 - `" "`        *not* an empty vector, contains a space
 - `0 3 # " "`  empty character matrix with 0 rows, but 3 cols
 - `3 0 # 0`    empty numeric matrix with 0 cols but 3 rows
 - `3 0 3 # 0`  empty numeric array of rank 3
 
 There are many ways to create empty arrays, as we shall discover in the following chapters.
We shall see later that empty arrays, which you may find surprising, are extremely useful in
solving a large number of business problems. If fact, they are often used as the starting point
(initial value) for variables that will grow by the iterative addition of new items.

The empty numeric vector is probably the most frequently used of all empty arrays. For that
reason, a special symbol has been designed to represent it: `theta` (entered by pressing Ctrl+] ).
Because this symbol is made of a Zero with a Tilde on top of it, it is called Zilde.














 





## 2.8 Workspaces and commands

 - `\t` time

This is used by doing `\t x` where `x` is the function to time. For example, enumerating numbers using `!`:

```{}
0
 \t m:!1000000
1
 \t m:!10000000
9
 \t m:!100000000
86
 \t m:!1000000000
```

The time output is in milliseconds. So enumerating numbers from `0` to `100000000` (one hundred million), takes approximately 90 milliseconds on my laptop. *Note: results will vary, depending on the computer. And, be careful - enumerating to a number too large can easily cause a segmentation fault.*

 - `\v` variables
 - `\l` load
 - `\f` functions
 - `\a` ancestors
 - `\d` directory
 - `\w` workspace

### File extensions

File extensions in k6 `.k`

### Exiting K

Exit using a backslash `\` (remember that this is a comment, a forward slash: `/`).


----------

### Advanced section

#### TBD




-----------


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
\newpage
 


# Chapter 3: Some Primitive Functions








## 3.1 Definitions
In APL data is processed using what we call Functions. It is important to distinguish between:

 
* Primitive Functions 
    + They are part of the APL language.
    + They are represented by symbols: `+ - &` ...
    + They cannot be modified.

* User Defined Functions 
    + As their name implies, they are written by the user.
    + They are represented by names: Average, Budget ...
    + They can be modified.

APL has a very rich set of primitive functions. In this chapter, we will explore just a few of
them; many others will follow in subsequent chapters.

In the introduction to this book, we mentioned that in traditional mathematics, some symbols
can be used with a single argument or two arguments. For example

In the expression `a = x - y` the minus sign indicates subtraction.
Whereas in `a = -y` the minus sign indicates the negation of y, that's different.
The first form is called the **Dyadic** use of the symbol. The second form is called the **Monadic** use of the symbol.

It is the same in K, where most of the symbols (functions) have a monadic and a dyadic
meaning. For example:

```{}
t: # var           / example 1
t: 3 3 # var       / example 2
```

In the first example, `#` obtains the shape of the variable. In the second, `#` creates an array of shape `3 3` using `var`. 

There is, however, a major difference. In traditional mathematics, the symbol representing a monadic function is sometimes placed before its argument (as in: `a = -y`), sometimes after it (as in: `a = y!`), sometimes on both sides (as in: `a = |y|`), and some other conventions may be found.

In K, it is more simple: the symbol representing a monadic function is always placed before its argument, as
in `# var` .

 













## 3.2 Some Scalar Dyadic Functions

### Definitions and examples

Scalar dyadic functions are primitive functions which have the following properties:
 
 - They are Dyadic (require an argument on both sides).
 - They work item by item (scalar by scalar).
 - They can work on two arrays of the same shape, in which case the result also has the same
shape.
 - They can work on one array of any shape, and a single value (a scalar or any one-item
array), in which case the result has the same shape as the non-singleton array.

The four basic arithmetic functions *Addition, Subtraction, Multiplication* and *Division* are
scalar dyadic functions. They apply themselves between each item of the left argument and
the corresponding item of the right argument, like this:

```{}
 5 3 2 9 % 2 6 8 4
2.5 0.5 0.25 2.25

 2 3 # 6 8 2 1 9 3
(6 8 2
1 9 3)
```

In the first example, the function takes two 4-item vectors and results in another 4-item vector (as with all simple arithmetic functions (`+ - * %`)) and is a scalar function.  The second example is *not* a scalar function. There is nothing in common between the shapes of the arguments that reshape `#` takes.

Scalar dyadic functions apply to arrays of any rank and shape. As we saw in the introduction, a Sales Director makes forecasts for sales of 4 products over the coming 6 months, and assigns them to the variable `Forecast`. At the end of the 6 months, he records the actual values in the variable `Actual`. Here they are:

```{}
Forecast:(150 100 110 190 80;300 100 50 200 330;250 120 100 80 80;
360 400 500 520 350;380 400 450 220 300)
Actual:(141 188 111 87 82;321 306 352 403 497;118 283 397 424 411;
43 91 187 306 318;92 67 551 121 79)
```

The first thing any self-respecting Sales Director will want to know is the difference between
the expected and the actual results. This can be done easily by typing:

```{}
 Actual - Forecast       / matrix-matrix calculations result in the same shape 
(-9 88 1 -103 2
21 206 302 203 167
-132 163 297 344 331
-317 -309 -313 -214 -32
-288 -333 101 -99 -221)
```

But remember, a scalar dyadic function may also be applied between a single value and an
array of any shape.
For example, if we want to multiply `Forecast` by 2, we can type:

```{}
 Forecast * 2
(300 200 220 380 160
600 200 100 400 660
500 240 200 160 160
720 800 1000 1040 700
760 800 900 440 600)
```


### Division by Zero

An expression such as `17 % 0` leads to an, at first, odd result: `0w`, because zero does
not belong to the domain of valid denominators. In K, `0w` means *infinity*. However, `0 % 0` returns the result of `0n`, also known as *NaN* (not a number).

### Power

In K, there is no defined symbol used for the mathematical notation $A^{n}$ (*power*). Instead, we can define power as `power:{*/x#y}`. Then do `power[5;2]` which results in `32`.

Given that K is a relatively minimalist language, striped down to what is necessary, it is possibly understandable that power is not a built-in function.

### Maximum and minimum

Maximum (`|`) and Minimum (`&`) return respectively the larger of two values and the smaller
of two values, whatever their signs. Because they are scalar dyadic functions, they can be
applied item by item between any two compatible arrays.

```{}
 5 | 4
5
 5 & 4
4
 5 | 3 1 353 12 3 44 6
5 5 353 12 5 44 6
 12 12 2 3 5 0 111 | 3 1 353 12 3 44 6
12 12 353 12 5 44 111

```

Minimum can be used to apply a limit to the values in an array. For example, to set a ceiling of
450 in the matrix `Forecast`, it is sufficient to type:

```{}
 Forecast & 300
(150 100 110 190 80 
300 100 50 200 300 
250 120 100 80 80 
300 300 300 300 300
300 300 300 220 300)
```

So that values >300 have been limited to 300 (replaced with `300`).

### Relationship

K provides the 6 relationship functions, `<, >, =, ~=, `

```{}
 A:5
 B:4
 A < B
0
 A > B
1
 A = B
0
 ~A=B
1
```


**What about >= and <=?**

The results are called binary, or Boolean, values (Boolean refers to the name of the
mathematician George Boole). They can be processed in many different ways and are
extremely useful, as we shall soon see. Note that functions like `>` can inadvertently be applied to characters, which may yield odd results. E.g., `"a" < "b"` gives `1`. `"a" > "b"` gives `theta`. This is because the ASCII code for `a` is less than `b`. (`a`'s ASCII code is 97; `b`'s is 98.)

### Modulo

The modulo (or `mod`) function, represented by `!` , returns the remainder of a division.
In the expression `m: x ! y`, `m` is the remainder of `y` divided by `x` (be careful; the arguments of
`mod` are given in the *reverse order* of that used by `division` (`%`) `y % x` ).

```{}
 3 ! 7     / as expected if you divide 7 by 3 twice, you get 1
1
 
 7 ! 3     / be careful, this doesn't immediately make sense!
3
```


 












## 3.3 Order of evaluation

Like other programming languages, K allows the programmer to use parentheses to specify
the order of evaluation of a complex expression. In the absence of parentheses, it's good to know the order of operations, so you don't get burned by an unexpected result. So, it's important to test some examples:

```{}
 5 + 6 % 3 * 2
6
 (5 + 6) % 3 * 2
1.833333

```

The above two examples are not processed the same, though you may have thought `+` would be run before `*` and `%`. In K, equations are (generally) processed from right to left.

```{}
  5 + 6 % (3 * 2)
6
  5 + (6 % 3 * 2)
6
  5 + (6 % 3) * 2
9
```

By applying parentheses, you see that the equation runs from right to left, with `5` being added last. 
One more example to drive this oddity home:

```{}
  5 - 6 + 3 - 2
-2
  (5 - 6) + 3 - 2
0
  5 - 6 + (3 - 2)
-2

```

So, `3 - 2` runs before `5 - 6`...  Play with the order of operations in K a little bit to ensure you understand what is happening in your work (or, just use a liberal amount of `()`).  



 














## 3.4 Monadic scalar functions

### The four basic symbols

Now let's quickly go over the four basic functions `+ - * %`. Quickly, because this may seem repetative, but, as you will see, they have more functions when used monadically.

#### Flip

The plus `+` sign used monadically is the *flip* function.

```{}
 mat:(1 2 3;4 5 6)
 mat
(1 2 3
4 5 6)
 +mat
(1 4
2 5
3 6)
```

#### Negate

The minus `-` sign used monadically is the *negate* function.

```{}
 - 1 -5 82
-1 5 -82
```

#### First

The multiplication `*` sign used monadically is the *first* function, where the first item in a list is extracted.

```{}
 * 1 2 3 4 5
1
 *| 1 2 3 4 5        /thus, * with the reverse symbol (|) becomes *last* 
5
```


#### Square root

The division `%` sign used monadically is the *square root* function.

```{}
 % 4
2
 % 4 5 6 7 8 9
2 2.236068 2.44949 2.645751 2.828427 3
```


### Other scalar monadic functions

#### exponential

**Not sure how to do exp in K**

#### Floor and ceiling

Floor `_` rounds its argument(s) down, while ceiling `_ n + 1` rounds up, to the nearest integer:

```{}
 _ 1.5 12.1 10.3
1 12 10
 _ 1.5 12.1 10.3 + 1
2 13 11
```

So, although K does not have a designated function for *ceiling*, `_ n + 1` works in all cases. Another quick, more comphrensive look may be more convincing:

```{}
 _ 0.5 0.6 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 1.5
0 0 0 0 0 1 1 1 1 1 1
 _ 0.5 0.6 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 1.5 + 1
1 1 1 1 1 2 2 2 2 2 2
```


** Not sure how to do ceiling in K**

#### Absolutue

The monadic stile represents the absolute (unsigned) value of its argument, as shown:

** Not sure how to do absolute in K**


#### Comparison symbols

Like many of the other symbols in K, the comparison symbols `< > = ~=` all have monadic usages.

`<n` is asc, also known as "grade up". Generate a permutation vector which would sort argument into ascending order.

```{}
  <5 8 2 7
2 0 3 1
```


Similarly, >l is desc, also known as "grade down". Generate a permutation vector which would sort argument into descending order.

```{}
  <5 8 2 7
1 3 0 2
```

=l is group. Generate a dictionary from items to the indices where they were found.
```{}
  =`c`a`b`b`a`c`a
[c:0 5;a:1 4 6;b:2 3]
```

=n is identity matrix. Generate an NxN identity matrix.
```{}
  =3
(1 0 0
 0 1 0
 0 0 1)
```

~n is not. Nonzero numbers become 0 and 0 becomes 1. Right atomic.
```{}
  ~(0 1;3 7 -1)
(1 0
 0 0 0)
``` 

 















## 3.5 Processing binary data

Binary values are most often produced by the comparison functions that we have already seen.
However, the result of any function (such as addition or subtraction) which is composed only
of 1s and 0s can be used as a binary (or Boolean) value, and may be used as an argument to
any of the special primitive functions that apply to Boolean values.
Among the various ways of producing binary results, Membership appears to be one of the
most interesting tools.

### Membership

 - Membership tells whether the items of its left argument are present (`1`) or not (`0`) in the
right argument, regardless of their position in it.
 - It accepts arguments of any shape or type.
 - The result produced always has the same shape as the left argument.

Some examples will help you understand the function:

```{}
 40 1 12 23 in 17 88 19 50 51 52 23 40
1 0 0 1
```

This means that 23 and 19 appear somewhere in the rightmost vector, whereas 14 and 41 do
not. The left argument has 4 items, and so has the result.
The Membership function can operate on arguments of completely different shape. For
example, it is possible to detect the presence of each item of a vector in a matrix, or vice
versa.

In Chapter B we used a matrix containing the 6 first months of the year:

```{}
 MonMat
("January "
"February"
"March   "
"April   "
"May     "
"June    ")
```

We can ask if certain letters are present in this matrix, comparing the matrix `MonMat` and the vector `December`:

```{}
 MonMat[;] in "December"
(0 0 0 0 0 1 0 0
0 1 1 1 0 0 1 0
0 0 1 1 0 0 0 0
0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0)

```

### Binary algebra

Binary values can be processed using half a dozen specialised primitive functions, the main
ones being **And**, **Or**, **Xor**, and **Not**. Additional functions will be described in the Specialist's
Section.
The function And is represented by the symbol `&`, as it is in mathematics. It returns
the result `1` if the left *and* the right arguments are both equal to 1:

```{}
 0 & 0
0
 1 & 0
0
 0 & 1
0
 1 & 1
1
```

Just like many other things in K, those four expressions can be combined into one:

```{}
 0 0 1 1 & 0 1 0 1
0 0 0 1
```

The function *Or* is represented by the symbol `|`, as it is in mathematics. It returns
the result 1 if the left or the right argument is equal to 1.
The four possible cases are shown in the following expression:

```{}
 0 0 1 1 | 0 1 0 1
0 1 1 1
```

*Xor* is an acronym for *eXclusive Or*. It returns the result `1` if one of the arguments is equal to
`1`, but not if both are equal to `1`.

K does not need a different symbol for the function, because *Xor* is the same as the
comparison function that we have already met: `~=`

```{}
 ~ 0 0 1 1 = 0 1 0 1
0 1 1 0
```

The last function is the monadic function Not. Represented by the Tilde (`~`) , it
converts `0` into `1` and `1` into `0`:

```{}
 ~ 0 1 0 0 0 1 1
1 0 1 1 1 0 0
```

All these functions can be applied to binary data of any shape. For example, lets us see if any
of those items of `Forecast`, which are greater than 300 thousand Euros, have been exceeded
by `Actual` sales:

```{}
 bin:(Forecast>300) & (Actual>Forecast)
 bin
(0 0 0 0 0
0 0 0 0 1
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0)
```

A side note: The parentheses around the rightmost expression (Actual>Forecast) are not
strictly needed. However, they do no harm either, so we have added them here to help you
read the expression, since you may not yet be fully familiar with APL's order of evaluation.

### Except

`x ^ y` is *except*, where it removes each of x that's found in y. It can be used for both character arrays and arrays of numbers:

```{}
 "Congratulations" ^ "ceremony"
"Cgatulatis"

 1 2 3 4 5 6 7 8 9 ^ 1 3 5 7 9
2 4 6 8

```



 











## 3.6 Processing nested arrays

When working with nested arrays, it is important to recognise whether or not you are using a
scalar function.

### Scalar vs. non-scalar functions

Previously in Chapter B, we set up a nested vectors or and matrices, but let's create another one here composed only of numeric items: a nested vector called `nestvec`.

```{}
 nestvec:(10; 29; (1925; 9072; 984); 67; (1; 5; 4); 12; 9)
 nestvec[0]
10
 nestvec[1]
29
 nestvec[2]
1925 9072 984
```

One way of expressing this behaviour is to say that the scalar functions (both the dyadic and
the monadic ones) permeate down through the structure of nested arrays, until they reach the
lowest-level items, and then apply themselves at this level. They are said to be pervasive
functions.

Non-scalar functions, like Membership, are not pervasive.

```{}
10 in nestvec
1
 29 in nestvec
1
 5 in nestvec
0
```

Where `10` and `29` both match to the top level items found in `nestvec`, `5` does not, even though it's contained in nestvec. `5` is in the second level vector within the 5th item (`nestvec[4]`), so the memebership function `in` is not pervasive. However, if you check for membership of `nestvec[4]` specifically:

```{}
 5 in nestvec[4]
1
 1 5 4 in nestvec[4]
1 1 1
```

### Be careful with shape/type compatibility

It is easy to add a vector of 7 scalar items to `nestvec`, because each of the 7 scalars can be
added to the corresponding item of `nestvec`:

```{}
 nestvec
(10;29;1925 9072 984;67;1 5 4;12;9)
 nestvec + 1 2 3 4 5 6 7
(11;31;1928 9075 987;71;6 10 9;18;16)
```

But if we try to add a vector of 7 sub-vectors to `nestvec`, we must ensure that the shape of
each sub-vector is compatible with the shape of the corresponding item of `nestvec`:

```{}
 nestvec + (1; 2; (3; 3; 3); 4; (5; 5; 5); 6; 7)
(11;31;1928 9075 987;71;6 10 9;18;16)
```

This yields the same result as the much simplier `nestvec + 1 2 3 4 5 6 7`. Other methods you attempt to add to a nested array will likely result in a *value error*.




 













## 3.7 Reduction

### Presentation

Early on in this book, we calculated the cost of some items:

```{}
 Price:4.18 5.99 1.23 9.09 12.02
 Quant:2 4 7 11 1
 Cost:Price * Quant
 Cost
8.36 23.96 8.61 99.99 12.02

```

How much did we spend?
Mathematicians are creative people who long ago devised the symbol $\Sigma$, always with a pretty collection of indices above and below, which makes it complex to understand and difficult to type on a keyboard.
In APL, the operation is written like this:

```{}
 +/Cost
152.94
```

Simple, isn’t it? This expression gives the total of all the items in the vector. You can read this
as "Plus Reduction " of the variable Costs .
To gain a better understanding of the process:

When we write an expression such as `+/ 1 2 3 4 5`

 - it works as if we had written: `1 + 2 + 3 + 4 + 5`
 - and we obtain the same result: `15`

This same method works for many of the functions in K:

```{}
 |/ 1 2 3 4 5
5
 &/ 1 2 3 4 5
1
 */ 1 2 3 4 5
120
```

### Definition

Reduction, represented by the symbol `/`, belongs to a special category of symbols called
Operators.

In most programming languages the word operator is used to describe operations like
addition, subtraction, multiplication, and so on. In K such operations are called Functions;
typical examples are `+`, `-`, `*`, and `#`. The word operator has a separate meaning in APL.

In K a function works on an array or between two arrays to produce a result:

```{}
 Cost:Price * Quant
```

Whereas an operator applies to one or two functions (its operands) to produce what we call a
derived function.

In the expression: `Stock: +/ Quant`

the symbol `/` is the operator. It takes the function `+` as its single argument (operand) and
produces the derived function `+/`. This derived function is then applied to `Quant`, giving a result
which is assigned to `Stock`.

Please note that the argument to a monadic function is always to the right of the function,
whereas the function applied to a monadic operator (its operand) is always to the left of the
operator.

Many, although not all, of the K primitive functions may be used as the operand to
Reduction; you can even apply a user-defined function. This generality makes Reduction, and
other operators, extremely powerful.

K provides a total of 10 such powerful operators, listed in appendix 4. It is also
possible to write your own operators, just as it is possible to write your own functions.


### Reduction of Binary Data

Among the typical usages of Reduction are `&` (*And*) and `|` (*Or*) applied to binary data.

 - `&/ Bin` gives the result 1 if All the items of Bin are equal to 1
 - `|/ Bin` gives the result 1 if At least one of the items of Bin is equal to 1
 - `+/ Bin` tells us How many items of Bin are equal to 1

You can verify it on some small examples:

```{}
 &/ 1 1 1 0 1 0 1
0
 &/ 1 1 1 1 1 1 1
1
 |/ 1 1 1 0 1 0 1
1
 +/ 1 1 1 0 1 0 1
5
```

For example, in Chapter B, we created a vector named `Contents`:

`Contents:12 56 78 74 85 96 30 22 44 66 82 27`

Are all the values greater than 20? `&/ Contents > 20`

 - The answer is no: `0`

Is there at least one value smaller than 30? `|/ Contents < 30`

 - The answer is yes: `1`
 
How many values are smaller than 30? `+/ Contents < 30`

 - The answer is: `3`
 

### Reduction of Nested Arrays

When you apply reduction to a nested array you must check that the items of the nested array
are compatible (in shape and type) with the function that you intend to apply:

```{}
 +/ ((4;8);(1;4);10;(9;5))  / All the items can be added together
24 27

+/ ((4;8);(1;4);(1;2;3);(9;5))  / (1 2 3) has too many items
^
length error
```

### Application 1

The employees of a company are divided into three hierarchical categories, denoted simply 1,
2, and 3. Two variables contain the salaries and the categories of these employees; i.e.:

`Salaries:4225 1619 3706 2240 2076 1389 3916` 
`3918 4939 2735 912 1567 3451 1490 2111`

`Cat: 3 1 3 2 2 1 3 3 3 2 1 1 3 1 2`


The employees ask for an increase in their salaries. Each category of employee requests a
different percentage increase, as shown in the following table:

Category | Upgrade
---------|----------
1 | 8%
2 | 5%
3 | 2%

How much is that going to cost the company?
Let us just create a variable containing the three rates shown above:

```{}
 Rates: 8 5 2 % 100
 Rates
0.08 0.05 0.02
```

The first employee is in category 3, so the rate that applies to this person is:

```{}
 Rates[2]
0.02
```

More generally, the rates applied to all of our employees can easily be obtained like this:

```{}
 Rates[Cat-1]           / it's Cat-1 because 0-indexing
0.02 0.08 0.02 0.05 0.05 0.08 0.02 0.02 0.02 0.05 0.08 0.08 0.02 0.08 0.05
```

Having the rates, we only have to multiply them by the salaries to obtain the individual
increases:

```{}
 Salaries * Rates[Cat-1]
84.5 338 84.5 211.25 211.25 338 84.5 84.5 84.5 211.25 338 338 84.5 338 211.25
```

Finally, by adding them all together, we discover how much it will cost the company:

```{}
 +/ Salaries * Rates[Cat-1]
3042
```

Note that:

 - The expression remains valid regardless of the number of employees or categories.
 - The result has been obtained without writing a program (no loops, no tests).
 - This expression can be phrased in the simplest possible English, namely:
     + *Sum the Salaries multiplied by Rates according to Categories*

This illustrates how the implementation of a solution in APL can be very close to the way that
the solution would be expressed in everyday language. It also shows the advantage of not
having to deal with trivial and "irrelevant" matters such as lo



 












## 3.8 Axis Specification

### Totals in an Array

#### Processing Arrays

We have seen the result of applying reduction to vectors, but what about matrices and higher
rank arrays?

As an example let us recall the array `Prod`. Its three dimensions represent respectively:
 
 - 1 - 5 years
 - 2 - 2 assembly lines
 - 3 - 12 months

We can calculate totals along any one of these 3 dimensions: Years, Lines, and Months.
We specify the dimension (or Axis) between brackets after the Reduction symbol:

`+/[Axis] Prod`

For example, suppose that we want to calculate the total production for the five years for the first assembly line. Years are represented by the 1st dimension of `Prod`, so we write `Prod[;0]`.

```{}
 Prod[;0]
(26 16 22 17 21 44 25 22 23 44 41 33
44 21 58 57 17 43 47 17 43 26 53 23
37 27 53 26 29 46 25 26 30 20 32 16
21 57 55 44 16 54 26 16 55 56 45 26
36 47 49 30 22 57 20 45 60 43 22 44)

 +/Prod[;0]
164 168 237 174 105 244 143 126 211 189 193 142
```

`+/Prod[;0]` adds the five years together, resulting in the sum of production for each month over the five years. As a logical extension of `+/`, in order to add all of the months together:

```{}
 +/+/Prod[;0]
2096
```

which is the total production, over five years, for the first assembly line.

In the last look at `Prod`, finally, if we seek to sum the total production over five years for both assembly lines, we can make use of `!2`, which yields `0 1`. Combining this with `Prod`:

```{}
 +/+/Prod[;!2]
329 358 406 346 313 412 316 293 386 428 369 287
 +/+/+/Prod[;!2]
4243
```

So there, you have it, to obtain the sum of all production, we had to go three layers deep `+/+/+/`, which makes intuitive sense for a three dimensional array. 

#### Axis is like an operator

The dimension specified within brackets is the axis along which the function is applied.
This produces a derived function, and for this reason, the pair of Axis brackets is often called
the Axis Operator.
The syntax for Axis does not quite follow the general syntax for operators, but it shares all
other properties with genuine operators. Axis takes a function as its left operand (the derived
function +/ in the last example above), the dimension specification as its “right operand” (3 in
the example), and produces a derived function, which is applied to Prod to calculate the
annual sums.
Viewed as an operator Axis is therefore dyadic. It is, however, important to emphasise that its
"right" argument is not Prod , it is the expression within the brackets. This shows that a dyadic
operator does not need to have two functions as operands; one of them may be an array.

#### Processing arrays

We shall learn more about Axis in Chapter J; let us first explore another simple use of this
operator.
Suppose that we would like to multiply each of the rows (or columns) of a matrix by different
values; we can use Axis to specify whether we multiply row-wise or column-wise, like this:

```{}
 Tam:3 5 # 2 3 5 8 8 4 6 2 5 9 1 4 9 7 8
 Tam
(2 3 5 8 8
4 6 2 5 9
1 4 9 7 8)
```

Now let's multiply, row-wise:

```{}
 Tam * 5 0 7
(10 15 25 40 40
0 0 0 0 0
7 28 63 49 56)
```

As you can see, multiplication is, by default, row-wise. If you want to do column-wise multiplication, simply use transpose (`+`): 

```{}
 (+Tam) * 0 5 0 7 0
(0 0 0
15 30 20
0 0 0
56 35 49
0 0 0)
```


### The shape of the result

 - The dimensions of `Prod` are: `5 2 12`
 - `+/Prod` sums the 1st dimension and gives a result of shape: `  2 12`
 - `+/+Prod` sums the 2nd dimension and gives a result of shape: `5   12`
 - `+/+ +/+Prod` sums the 3rd dimension and gives a results of shape: `5 2   ` this isn't right....

You can see that Reduction of a 3-D array gives a 2-D array, in which the summed dimension
has "disappeared". This is the origin of the term "Reduction"; it reduces the rank of the array.
This rule will help you predict the dimensions of the result of a reduction.


 















## 3.9 Our first program

The expression we wrote in section 7.6 to calculate the average of a set of values, is one that
we may want to use time and time again. So let us store it as a program, or, to use the proper
APL terminology, as a User Defined Function.
There are many different ways to define functions, and these will be covered in detail in
Chapter D. For now we shall use the simplest, which is perfectly suitable for straightforward
calculation functions like this one. Let's type:

```{}
 Average:{+/x%#x}
 Average
{+/x%#x}
```

`Average` is the name of the function.
It is followed by the definition, delimited by a pair of curly braces `{` and `}`.

`x` is a generic symbol that represents the array that will be passed as the right argument of the function.

For more complex multi-line functions it is obviously more appropriate to use a text editor.
However, this is beyond the scope of this chapter.
Once defined, this function may be invoked directly, just as if it were a built-in (primitive)
function:

```{}
 Average 1 5 10
5.333333
```

The word `Average` can now be used in any K expression. We have enriched the
vocabulary which can be used to process data in this workspace (provided that we save it).
Be patient: We shall see many other possibilities in Chapter 4.


















## 3.10 Concatenation

Concatenation is a dyadic function which joins two arrays together. It is represented by
comma (`,`). The function name is normally abbreviated to Catenate, and we will use both
terms.

### Concatenation vectors

Catenate is easy to understand:

```{}
 a:5 3 1 2
 b:7 9 0 4
 a,b
5 3 1 2 7 9 0 4
```

It is like joining two sentences together, so it is easy to remember which symbol to use.
You can see that `#a,b` is equal to `#a` + `#b`.

Character strings are processed in the same way:

```{}
 a:"Tell me"
 b:"More"
 a,b
"Tell meMore"
```

Note that there is no space inserted between the contents of the two vectors. When we join a
vector of 7 characters to a vector of 4 characters, the result must have 11 characters.
When you concatenate an empty vector to another vector, the result is the same as the
original:

```{}
 n
24 15 67 89
 v:""
 n,v
24 15 67 89
```

### Concatenating other arrays

It is possible to concatenate two arrays if their shapes are compatible. The axis along which
the concatenation is to be performed must be specified, if it is different from the default.

Let us use three matrices A, B, and C:

```{}
 A:3 4 # "A"
 B:2 4 # "B"
 C:3 3 # "C"
 A
("AAAA"
"AAAA"
"AAAA")
 B
("BBBB"
"BBBB")
 C
("CCC"
"CCC"
"CCC")
```

The possible concatenations are:

```{}
 A,B        / produces a 5 x 4 matrix
("AAAA"
 "AAAA"
 "AAAA"
 "BBBB"
 "BBBB")
 +A,B       / produces a 4 x 5 matrix  
("AAABB"
 "AAABB"
 "AAABB"
 "AAABB")
```

Again, notice the usage of transpose in `+A,B`.

Unlike APL, in K you can concatenate matrices of incompatible sizes, because matrices in K are lists of vectors.
Thus, you can do this:

```{}
 C,B
("CCC"
 "CCC"
 "CCC"
 "BBBB"
 "BBBB")
```

For another example, in order to make `A` and `C` concatenate nicely, you have to use two `+`:

```{}
 +C,+A
("CCCAAAA"
 "CCCAAAA"
 "CCCAAAA")
```














## 3.11 Replication

### Basic Approach: Compression

To extract scattered values from a vector, we can use indexing. Previously, we showed how to use a mask for selecting items using corresponding binary values from another array:

```{}
  & 1 2 3 4 5 6 ! 1 0 0 1 1 0
1 4 5

  & "abcdef" ! 1 0 0 1 1 0       / and for character data 
"ade"
```


To do this you need to use `!`, also know as the *map* function, and `&` (*where*). These statements can be read as "where *x* maps to *y*". This is extremely useful, because we can use Compression to select items which match a given condition.

For example, let us extract from `Contents` the values which are greater than `80`.
The Boolean vector for the left argument is obtained by `Contents>80`, and the selection is
made by:

```{}
 Contents:12 56 78 74 85 96 30 22 44 66 82 27
 & Contents ! Contents>80
85 96 82
```

*Note: this is the opposite of compression in APL, where you'd do something like `Contents>80 ! Contents`*

Of course, the same operation can be applied to any array, provided that one specifies which
axis is concerned. For example, if we have a matrix of chemical formulas:

```{}
 Chem:("H2SO4";"H2O2";"CO2";"CH4")
 Chem
("H2SO4"
 "H2O2"
 "CO2"
 "CH4")

 & Chem ! 1 0 1 0
("H2SO4"
 "CO2")

 & Chem[;!2] ! 1 0 1 0    / selecting the first two columns in Chem
("H2"
 "CO")

 & Chem ! Chem[;0]="C"    / selecting compounds starting with carbon
("CO2"
 "CH4")

 & Chem ! "H"in' Chem     / selecting compounds containing hydrogen
("H2SO4"
 "H2O2"
 "CH4")

```

And a final example with numbers, using `Contents`. Here we extract only the even numbers:

```{}
 & Contents ! (~ 2 ! (Contents))
12 56 78 74 96 30 22 44 66 82        / the odd 85 and 27 are not returned
```

In this potentially confusing example, the verb `!` is used in two different contexts. First it's used as *modulo* where it yields the binary vector of mod 2. Then it's used as *map*.

Compression (`&x!y`) is an excellent tool which allows you to:

 - extract some useful items from a variable,
 - or remove some unwanted items from a variable, which is the same thing.


### Replication

In fact, Compression is just a special case of a more comprehensive function named
Replication or Replicate. Its left argument can be any vector of integer values, each of which
produces the following result:

 - If the left item is *positive*: each item in the right argument is replicated the number of
times specified by the corresponding item of the left
argument.

 - If the left item is *zero*: the corresponding item in the right argument is suppressed.

The concept of a "Fill item" is new and will be discussed in full in Chapter I on “Nested
Arrays”. For now, you need only to know that the fill item for a simple numeric array is 0,
and the fill item for a simple character array is a space (blank).

Here are some examples, using the same left argument applied to numeric and character
vectors:

```{}
 & "boat" ! 0 1 3 0
"oaaa"

 & 42 15 79 66 ! 0 1 3 0
15 79 79 79
```












## 3.12 Position (index of)

### Discovery

It is very often necessary to locate the positions of particular values in a list of items. To solve
this, APL has a special function named Position (also called "Index Of"), represented by the
Greek letter Iota (`!`). This symbol can be obtained by Ctrl +I (the initial letter of Iota). Let us
see how it works:

```{}
 Vec:15 42 53 19 46 53 82 17 14 53 24
 Vec ? 19 14 53 49 15
3 8 2 11 0
```

 - The result tells us that 19, 14, and 15 appear in positions 3, 8, and 0 respectively.
 - The result also tells us that 53 appears in position 3. This is of course true, but it also
appears in positions 6 and 10, which are not included in the result. This is a necessary
restriction: If we had searched for 5 values and obtained 7 results, it would not have been
possible to say where each value appears. This is the reason why Index Of returns only the
first occurrence of each value. We shall see later that this is an advantage: If instead we need to find all the positions in which a value occurs, there is another function that we can use (see section 13.2).
 - Surprisingly the result tells us that 49 appears in position 12, though Vec has only 11
items! This is the way that Index Of indicates a missing value. We shall see that it is a
great advantage, too.

The following rule explains how dyadic `?` (*find*) works:
 
 > - `Vec`: Must be a vector.
 > - `Data`: Can be any array (any type, any shape, any rank).
 > - `R`: Has the same rank and shape as `Data`
 > - The items of `R` contain the positions of the first occurrence of the corresponding
items of `Data` in `Vec`
 > - Items which do not appear in `Vec` give the result `1 + #Vec`



```{}
 Alpha:"ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789"
 Alpha ? Chem
(7 29 18 14 31
 7 29 14 29
 2 14 29
 2 7 31)
```

The function Index Of is one of the most important primitive functions in K. It is very
flexible, and it can be used in many situations, as shown in the following examples.

### Application 3

A car manufacturer decides that he will offer his customers a discount on the catalogue price.
The country has been split into 100 geographic areas, and the discount rate will depend on the
geographic area according to the following table:



Area | Discount
-----|---------
17 | 9%
50 | 8%
59 | 6%
84 | 5%
89 | 4%
----|----
Others | 2%



The problem is to calculate the discount rate that may be claimed for a potential customer who
lives in given area *D*; for example *D:84*.

Let's start by creating two variables, based on the table, and then see if 84 is in the list of favored areas:

```{}
Area:17 50 59 84 89
Discount:9 8 6 5 4 2

  D in Area
1
  Area ? D
3
```

Let us find the current rate of discount for this index position:
```{}
  Discount[3]
5  
```

So the customer can claim a 5% discount! Another way to write this is to simple do: `Discount[Area?D]`.
If a customer lives in any area such as 75, 45, or 93, the expression `Area?D` will in all cases
give the result 6, because those values are absent in `Area` . Then `Discount[6]` will always
find the rate 2%, as expected.

#### A vector solution

The importance of this approach to finding the discount rates is that it is vector-based.
Suppose that publicity attracts crowds and that therefore D is no longer a scalar but a vector,
the solution is still valid:

```{}
D:24 75 89 60 92 50 51 50 84 66 17 89
 Discount[Area?D]
2 2 4 2 2 8 2 8 5 2 9 4
```

We have achieved all this without a program, neither a "loop" nor a "test". And it works for
any number of areas. Readers who know other programming languages will probably
appreciate the simplicity of this approach.

#### Generalization

In reality, the expression that we have just written is an example of an algorithm for
"changing the frame of reference". Don’t panic, this term may seem esoteric, but the concept
is simple: a list of area numbers (the initial set) is translated into a list of discount rates (the
final set). The algorithm comprises only the function Index Of and indexing:

 > `R:FinalSet[InitialSet ? Values]`

Let us imagine the initial set to be an alphabet composed of both lowercase and uppercase
letters, and the final set to be composed of only uppercase letters, with a blank space in the
middle:

```{}
 alphLower:"abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 alphUpper:"ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ*"
```

Now, let us write a sentence; we will write it in French in order only to show what happens
with missing characters.

```{}
 tale:"Le Petit Chaperon-Rouge a bouffé le Loup"
``` 

If we apply the algorithm seen above, the expression will convert the text from lower to upper
case: 

```{}
  alphaU[alphaL?tale]
"LE PETIT CHAPERON*ROUGE A BOUFF** LE LOUP"
```

As one might expect, the characters `–` and `é` , which are absent from the initial alphabetic set,
have been replaced by the `*`, the “extra” character at the end of the final set. This works
because once again the final set is one item longer than the initial set.

Once more, the logical steps needed to solve the problem are easily translated into a
programming solution, and the programmer can thereby direct all his attention to solving the
problem.













## 3.13 Index Generation

### Basic Usage

When used as a monadic function, the symbol Iota generates a vector of the first N integers. It
is called *Index Generator*.

```{}
 !9
0 1 2 3 4 5 6 7 8
```

If we have to extract the first 12 items of a vector `vec`, we can write: `vec[0 1 2 3 4 5 6 7 8 9 10 11]`

It is, of course, much easier to write `vec[(!12)+1]`. The result can be combined with simple arithmetic operations. For example, suppose we need
to produce the following list of 6 values: 115 122 129 136 143 150 (note the increments of 7).
We can do this as follows:

```{}
 !6
0 1 2 3 4 5
 7*!6
0 7 14 21 28 35
 115+7*!6
115 122 129 136 143 150
```

More generally, any arithmetic series of integers can be produced by the following formula:

> `R:Origin + Step × (!Length)`

### Application 4

You probably remember that the function Index Of returns only the first occurrence of a value
in a vector (cf. section 12.1). Using monadic Iota we can build an algorithm to find all the
occurrences.
Here is a vector, in which we would like to find the positions of the number 19:

```{}
 vec:41 17 19 53 42 27 19 88 14 56 19 33
 vec=19
0 0 1 0 0 0 1 0 0 0 1 0
 !#Vec
0 1 2 3 4 5 6 7 8 9 10 11
```

If we compress the second vector by the first one, the only items that will remain will be the
positions of the target value:

```{}
  &(vec=19)&(!#vec)
2 6 10
```

The same technique will work on characters. Lets us search for the letter "a" in a character
vector:

```{}
   phrase:"Panama is a canal between Atlantic and Pacific"
   &(phrase="a")&(!#phrase)
1 3 5 10 13 15 29 35 40
```

#### A touch of modern maths

Having found all the "a"s, we may wish to find all the vowels.

Alas, although the expression `Phrase='a'` works because a vector can be compared with a
single value, the obvious solution `Phrase='aeiouy'` 3 does not. It is not possible to make an
item by item comparison of a phrase of 46 letters with "aeiouy", which has only 6 letters.

In other words: one may compare 46 letters with 46 other letters, or compare them with one
letter, but not with 6 letters.

Fortunately, the function Membership does exactly what we want:

```{}
 &(phrase in "aeiouy")&(!#phrase)
1 3 5 7 10 13 15 19 22 23 29 32 35 40 42 44
```

More generally, this algorithm can be used to search for some `Data` in a `Vector`:

> `R:&(Vector in Data) & (!#Vector)`

### Comparison of Membership and Index Of

We have discovered two different techniques, using the primitive functions, Index Of,
Membership, and Index Generator, that allow us to look up one set of values in another and to
determine the positions of the items of one set in the other. Depending on the problem that we
have to solve, we can choose which of the two methods will be most appropriate for the job in
hand. Consider the following example:

#### Example

A company named *Blue Hammer Inc.* has subsidiaries in a number of countries; each
country being identified by a numeric code. The country names are stored in a matrix named
`Countries`, and the country codes are stored in a vector named `Codes`. To make things
easier to read, let us show those two variables side by side:

Countries | Codes
-----|---------
France | 50
Great Britain | 4
Italy | 12
United States | 83
Belgium | 64
Swiss | 34
Sweden | 66
Canada | 81
Egypt | 37

So, Sweden is identified by 66, and Belgium is identified by 64.
All the sales made during the last month have been recorded in two vectors:

 > BHCodes: indicates in which country each sale has been made, and 
 > BHAmounts: indicates the amount of each sale.

Here are the two vectors. Many countries have not sold anything, whereas some countries
(like 12 and 83) have made several sales:

```{}
 BHCode: 83 12 12 83 43 66 50 81 12 83 14 66 41 37 9
 BHAmount: 609 727 458 469 463 219 431 602 519 317 663 631 199 542 486
```

#### First question

We would like to focus on some selected countries (14, 43, 50, 37, and 66) and calculate the
total amount of their sales. Let’s first identify which items of BHCodes are relevant:

```{}
 Selected: 14 43 50 37 66
 BHCode in Selected
0 0 0 0 1 1 1 0 0 0 1 1 0 1 0
```

Then we can apply this filter to the amounts, and add them up:

```{}
 BHCode ? Selected
10 4 6 13 5
 
 BHAmount[BHCode ? Selected]
663 463 431 542 219
 +/BHAmount[BHCode ? Selected]
2318

```

So `BHCode ? Selected` provides the position of `Selected` within `BHCode`. What happens if an item in `Selected` isn't found in `BHCode`?

```{}
 Selected: 14 43 50 37 66 99
 BHCode ? Selected
10 4 6 13 5 15
```

The missing item is given position 15, and, given `# BHCode` yields `15` and K is 0-indexed, that's 1 outside the index. 





### 3.14 Ravel

The function `ravel` is represented by the monadic use of the `,/` verb-adverb. Applied to any array, it returns all its items as a vector.
Naturally, if the array is already a vector, Ravel does not change anything. Let us see how it works on some matrices:

```{}
 tests
(52 12 93
 85 81 76
 99 49 56
 98 12 34
 53 45 12
 54 45 61)
 
  ,/tests
52 12 93 85 81 76 99 49 56 98 12 34 53 45 12 54 45 61
```

The items of the matrix have been strung out and returned as a vector.

```{}
 chem
("H2SO4"
 "CaCO3"
 "Fe2O3")
 
  ,/chem
"H2SO4CaCO3Fe2O3"
```

A common use of `ravel` is to transform a scalar into a one-item vector. The difference between a scalar and a one-item vector is not readily obvious, until you use it as an index into a matrix.

Suppose that you need to select a particular set of columns Cols from the matrix Forecast. As long as Cols contains more than one value, the result will be a matrix:

```{}
 cols: 0 3 5
 predict[;cols]
(150 190 70;300 200 500;250 80 110;360 520 420;380 220 90)
```

The rank of the result may be critical if some other expression in your program expects a matrix.
To make certain that your indexing expression always returns a matrix, you must ensure that your index will always be a vector by using Ravel:

```{}
 ,/predict[;cols]
150 190 70 300 200 500 250 80 110 360 520 420 380 220 90
```



# Chapter 4: User Defined Functions

## 4.1 Single-Line Direct Functions

### Definition

Single-line functions are created like this: `name:{definition}`.

Functions are enclosed in `{}` and consist of one or more expressions separated by semicolons (`;`). When evaluated, functions execute these expressions left to right and return the value of their final expression. The special names x, y and z are implicit arguments to a function. If all three are present, the function takes 3 arguments. If only x and y are present, the function takes 2 arguments. If only x is present, the function takes 1 argument. Functions are applied to arguments with `[]` or simply by juxtaposing the function and the argument in the case of single-argument functions:

```{}
 am:{+/x%#x}
 am[1 5 10]
5.333333
 am 1 5 10
5.333333
```

The developer does not need to declare anything about the shape or internal representation of the arguments and the result. This information is automatically obtained from the arrays provided as its arguments.

### Unnamed definition

A Direct function can be defined and then discarded immediately after it has been used, in which case it does not need a name. For example, the geometric mean of a set of N values is defined as the Nth root of their product. The function can be defined (temporarily), used, and then discarded, like this:

```{}
 {+/x%#x} 1 5 10
5.333333
```


This kind of function is similar to inline or lambda functions in other languages. A special case is `{}`; this function does nothing. However, placed at the left of an expression, it can be used to prevent the result of the expression from being displayed on the screen.

### Modifying the code

Single-line functions may be modified using the function editor, as will be explained later for procedural functions. They can also be redefined entirely, as many times as necessary, as shown:

```{}
 am:{+/x}
 am:{+/%x}
 am:{+/x%#x}
 am 1 5 10
5.333333
```

Multiline functions will be studied later, after we have had time to practise using the function editor.


## 4.2 Procedural Functions

Procedural functions, which are commonly referred to as traditional functions, are mainly used for complex calculations involving many variables, interactions with a user, file input/output of data, etc. They look much like functions or programs in more traditional programming languages.


### Local Names

Let's break down the `am` function into steps, and see how it functions: into `sums`, `counts`, and `divsc` (where you're dividing the `sums` by `counts`). 


```{}
 vec: 20 75 12 11;
 amean:{sums:+/x; counts:#x; divsc:sums % counts;}
{[x]sums:+/x;counts:#x;divsc:sums%counts}
 amean vec
29.5
 saveIt:amean vec
```

But after running that, let's see what's saved:

```{}
 vec
20 75 12 11
 amean
{[x]sums:+/x;counts:#x;divsc:sums%counts}
 saveIt
29.5
 sums
the name 'sums' has not been defined.
 counts
the name 'counts' has not been defined.
 divsc
the name 'divsc' has not been defined.
```

But `sums`, `counts`, and `divsc` aren't defined! That's because `vec`, `amean`, and `saveIt` are all local variables. If we want to make the others stick around, we have to assign them as global variables by using `::`:

```{}
{[x]sums::+/x;counts::#x;divsc::sums%counts}
 amean vec
29.5
 sums
118
 counts
4
 divsc
29.5
```


### Miscellaneous

You can list all of the variables and functions that you've assigned by typing `\v` and `\f`, respectively.







## 4.3 Flow Control

### Overview

Apart from extremely simple calculations, most programs rely on certain statements being executed only if a given condition is satisfied (conditional execution), or on a set of statements being executed again and again, until a given limit is reached (looping). The APL language offers a special set of syntactic elements to control the flow of statements.
In the very first versions of APL, the only way to implement conditional execution and looping was to use the symbol → (branch arrow). This was used to jump from one statement to another, skipping over other statements (conditional execution) or jumping back to repeat a set of statements again (looping). The branch arrow is equivalent to the GOTO statement in other languages, and was once the only way to control execution flow in an APL program. Contemporary versions of APL include a special set of keywords which offer a much more flexible, easy to use, and easy to read way to control the flow of execution. They are also very similar to those used in most other languages. These are known as Control structures.
We shall begin by using control structures and then introduce you later to the old way of programming, only because you may come across it in some existing programs, and because it sometimes offers shorter or more convenient ways of doing things.

Control structures are blocks of statements which begin and end with special keywords. These
keywords are all prefixed with a colon, like :If or :Repeat .
The keywords can be typed in lower or upper case, but Dyalog APL will always store and display them using a fixed spelling convention, with an upper case first letter, and the following letters in lower case. Composite keywords like "EndIf" or "GoTo", are shown with the first letter of the second word also in uppercase.

### Conditional Execution

The symbol `$`, when used with 3 or more argument expressions is cond. Much like the Lisp construct, cond considers argument expressions two at a time. If the first in a pair evaluates to a truthy value, the second in the pair is evaluated and returned. Otherwise it continues with the next pair. If no conditions match, the final value is returned. For the purposes of cond, anything except 0, 0x00 or () is truthy.

```{}
 $[1;"A";0;"B";"C"]
"A"
 $[0;"A";0;"B";"C"]
"C"
```

Note that cond is a special top-level construct which evaluates subexpressions only according to the above rules. Side-effecting subexpressions make this more obvious:

```{}
  $[0;a:50; 1;a:25; a:13];
  a
25
```

You can often program without this type of conditional statement, but the short-circuiting behavior of cond is vital for writing recursive procedures:

```{}
  r: {$[1<#x; |r'x; x]};
  r (1 2;(3 4;5 6 7))
((7 6 5
  4 3)
 2 1)
```















# Chapter 5: First Aid Kit

# Chapter 6: Execute and Format Control





# Chapter 7: Working on Data Shape

In most programming languages the programmer has to declare the dimensions of an array statically, and it is often only possible to operate on the individual items using programmer- written loops.
In contrast to this, because APL processes arrays in their entirety, it is important to be able to manage the dimensions of an array dynamically. This is why this chapter presents a certain number of new tools that will help you perform these tasks.


## 7.1 Take and Drop

### Take and Drop Applied to Vectors

Two dyadic verbs, take (`#`) and drop (`_`), can be used to extract or remove the number of items specified in the left argument, starting from the beginning of a vector if the left argument is positive, or from the end of the vector if it is negative.

Take extracts the vector's head or tail, depending on the sign of the argument. Drop Removes the vector's head or tail, and hence selects the remaining part.

```{}
 a:46 78 55 96 11 64 22 14 30 45
 3#a
46 78 55
 -3#a
14 30 45
```

And it of course works the same on characters:

```{}
 b:"thisbookisabook"
 4#b
"this"
 -4#b
"book"
 -7#b
"isabook"
```

Drop works similarly, but the opposite:

```{}
 7_a
14 30 45
 -7_a
46 78 55
```

Drop is great, but --- and this will come up later --- what if I want to drop a specific number from a vector. Let's say, specifically the integer at index `4` in `a`. Introducing the dyadic _except!_ `^`:

```{}
 a[4]
11
 a^11                       / using its identity
46 78 55 96 64 22 14 30 45
  a^a[4]
46 78 55 96 64 22 14 30 45  / or just use its index
```

Remember that except is slightly different from both take and drop in that it you read it as "`a`, except `11`", whereas drop could be said as "remove (the first) `7` from `a`". 

### Back to take and drop

Some words of caution about the functionality of take: it will wrap, if you take more than exists in the vector. As an example, again using `a`:

```{}
 a:46 78 55 96 11 64 22 14 30 45
 20#a
 46 78 55 96 11 64 22 14 30 45 46 78 55 96 11 64 22 14 30 45
```

`#` will happily keep going, which could potentially cause issues if you create a function that assumes a vector of a certain size, but it won't simply result in an error. (You may not know there's an issue.) The equivalent issue does not arise when using drop:

```{}
 20_a
!0
```

You'll get back an empty vector.


## 7.2 Three Basic Applications










# Chapter 8: Special Syntax

# Chapter 9: Nested Arrays

# Chapter 10: Operators

# Chapter 11: Mathematical Functions




























